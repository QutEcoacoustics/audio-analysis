<?xml version="1.0"?>
<doc>
    <assembly>
        <name>PowerArgs</name>
    </assembly>
    <members>
        <member name="T:PowerArgs.ArgAction`1">
            <summary>
            This is the more complex version of the public result that is produced by the parser.
            </summary>
            <typeparam name="T">Represents the custom argument scaffold type that was passed to the parser.</typeparam>
        </member>
        <member name="T:PowerArgs.ArgAction">
            <summary>
            This is the weakly typed, more complex version of the public result that is produced by the parser.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgAction.Value">
            <summary>
            The instance of your custom scaffold type that the parser generated and parsed.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgAction.ActionArgs">
            <summary>
            If you used the action framework then this will represent the instance of the action specific arguments
            that were parsed.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgAction.ActionArgsProperty">
            <summary>
            If you used the action framework then this will map to the property that the user specified as the first
            parameter on the command line.
            </summary>
        </member>
        <member name="T:PowerArgs.ArgAction.ResolveMethodResults">
            <summary>
            The results from resolving the action method to execute.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgAction.ResolveMethodResults.MethodInfo">
            <summary>
            The method info of the action to execute. Used for reflection invocation.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgAction.ResolveMethodResults.Action">
            <summary>
            The System.Action&lt;TActionArgs&gt; to execute. Will be null unless
            an appropriate method is found. Note: This field is dynamic.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgAction.ResolveMethodResults.ExpectedReturnType">
            <summary>
            The expected return type of the action.
            </summary>
        </member>
        <member name="M:PowerArgs.ArgAction`1.Invoke">
            <summary>
            This will find the implementation method for your action and invoke it, passing the action specific
            arguments as a parameter.
            </summary>
        </member>
        <member name="M:PowerArgs.ArgAction`1.ResolveMethod(System.Reflection.PropertyInfo)">
            <summary>
            Given an action property, finds the method that implements the action.
            </summary>
            <param name="actionProperty">The property to resolve</param>
            <returns></returns>
        </member>
        <member name="P:PowerArgs.ArgAction`1.Args">
            <summary>
            The instance of your custom scaffold type that the parser generated and parsed.
            </summary>
        </member>
        <member name="T:PowerArgs.ArgLongForm">
            <summary>
            An attribute used to define long form aliases for argument
            names.  For example, --log-level instead of -log.
            It also supports an alternate syntax for providing the values.
            For example: --log-level=error instead of -log error or /log:error.
            </summary>
        </member>
        <member name="T:PowerArgs.ArgHook">
            <summary>
            An abstract class that you can implement if you want to hook into various parts of the
            parsing pipeline.
            </summary>
        </member>
        <member name="M:PowerArgs.ArgHook.BeforeParse(PowerArgs.ArgHook.HookContext)">
            <summary>
            This hook is called before the parser ever looks at the command line.  You can do some preprocessing of the 
            raw string arguments here.
            </summary>
            <param name="context">An object that has useful context.  See the documentation of each property for information about when those properties are populated.</param>
        </member>
        <member name="M:PowerArgs.ArgHook.BeforePopulateProperties(PowerArgs.ArgHook.HookContext)">
            <summary>
            This hook is called before the arguments defined in a class are populated.  For actions (or sub commands) this hook will
            get called once for the main class and once for the specified action.
            </summary>
            <param name="context">An object that has useful context.  See the documentation of each property for information about when those properties are populated.</param>
        </member>
        <member name="M:PowerArgs.ArgHook.BeforePopulateProperty(PowerArgs.ArgHook.HookContext)">
            <summary>
            This hook is called before an argument is transformed from a string into a proper type and validated.
            </summary>
            <param name="context">An object that has useful context.  See the documentation of each property for information about when those properties are populated.</param>
        </member>
        <member name="M:PowerArgs.ArgHook.AfterPopulateProperty(PowerArgs.ArgHook.HookContext)">
            <summary>
            This hook is called after an argument is transformed from a string into a proper type and validated.
            </summary>
            <param name="context">An object that has useful context.  See the documentation of each property for information about when those properties are populated.</param>
        </member>
        <member name="M:PowerArgs.ArgHook.AfterPopulateProperties(PowerArgs.ArgHook.HookContext)">
            <summary>
            This hook is called after the arguments defined in a class are populated.  For actions (or sub commands) this hook will
            get called once for the main class and once for the specified action.
            </summary>
            <param name="context">An object that has useful context.  See the documentation of each property for information about when those properties are populated.</param>
        </member>
        <member name="P:PowerArgs.ArgHook.BeforeParsePriority">
            <summary>
            The priority of the BeforeParse hook.  Higher numbers execute first.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgHook.BeforePopulatePropertiesPriority">
            <summary>
            The priority of the BeforePopulateProperties hook.  Higher numbers execute first.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgHook.BeforePopulatePropertyPriority">
            <summary>
            The priority of the BeforePopulateProperty hook.  Higher numbers execute first.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgHook.AfterPopulatePropertyPriority">
            <summary>
            The priority of the AfterPopulateProperty hook.  Higher numbers execute first.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgHook.AfterPopulatePropertiesPriority">
            <summary>
            The priority of the AfterPopulateProperties hook.  Higher numbers execute first.
            </summary>
        </member>
        <member name="T:PowerArgs.ArgHook.HookContext">
            <summary>
            Context that is passed to your hook.  Different parts of the context will be available
            depending on which part of the pipeline you're hooking into.
            </summary>
        </member>
        <member name="F:PowerArgs.ArgHook.HookContext.CmdLineArgs">
            <summary>
            The command line arguments that were passed to the Args class.  This is always available and you
            can modify it in the BeforeParse hook at your own risk.
            </summary>
        </member>
        <member name="F:PowerArgs.ArgHook.HookContext.ArgumentValue">
            <summary>
            The string value that was specified for the current property.  This will align with the value of ArgHook.Property.
            
            This is not available during BeforePopulateProperties or
            AfterPopulateProperties.
            
            </summary>
        </member>
        <member name="F:PowerArgs.ArgHook.HookContext.RevivedProperty">
            <summary>
            This is the value of the current property after it has been converted into its proper .NET type.  It is only available
            to the AfterPopulateProperty hook.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgHook.HookContext.Property">
            <summary>
            The current property being operating on.  This is not available during BeforePopulateProperties or
            AfterPopulateProperties.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgHook.HookContext.Args">
            <summary>
            This is the instance of your argument class.  The amount that it is populated will depend on how far along in the pipeline
            the parser is.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgHook.HookContext.ParserData">
            <summary>
            The raw parser data.  This is not available to the BeforeParse hook.  It may be useful for you to look at, but you should rarely have to change the values.  
            Modify the content of this at your own risk.
            </summary>
        </member>
        <member name="M:PowerArgs.ArgLongForm.#ctor(System.String)">
            <summary>
            Creates a new ArgLongForm attirbute using the given long form string.
            </summary>
            <param name="value">The long form value.  You can provide the two dashes in this string or not.  The --long-form pattern will enforced at runtime either way.</param>
        </member>
        <member name="M:PowerArgs.ArgLongForm.BeforeParse(PowerArgs.ArgHook.HookContext)">
            <summary>
            Finds instances of the long form alias on the command line
            and replaces it with a standard property specification.
            </summary>
            <param name="context">The context that has access to the command line args and the target property.</param>
        </member>
        <member name="T:PowerArgs.ArgReviverAttribute">
            <summary>
            The attribute used when you want to create an arg reviver. You should put this on public static methods 
            that take 2 string parameters (the first represents the name of the property, the second represents the string value
            and the return type is the type that you are reviving (or converting) the string into.
            </summary>
        </member>
        <member name="M:PowerArgs.ArgReviverAttribute.#ctor">
            <summary>
            Creates a new ArgReviverAttribute
            </summary>
        </member>
        <member name="T:PowerArgs.ArgActionType">
            <summary>
            Use this attribute if your action implementation methods are defined in a type other than the 
            type being passed to Args.ParseAction() or Args.InvokeAction().
            </summary>
        </member>
        <member name="M:PowerArgs.ArgActionType.#ctor(System.Type)">
            <summary>
            Creates a new ArgActionType attribute given the type that contains the action implementation.
            </summary>
            <param name="t">The type that implements your action methods.</param>
        </member>
        <member name="P:PowerArgs.ArgActionType.ActionType">
            <summary>
            The type that implements your action methods.
            </summary>
        </member>
        <member name="T:PowerArgs.ArgAllowNullAction">
            <summary>
            Use this attribute if you want to allow calling an action with no parameters (even if there are ArgRequired
            or other validation attributes attached the action property's members).
            </summary>
        </member>
        <member name="M:PowerArgs.ArgAllowNullAction.#ctor(System.Boolean)">
            <summary>
            Creates a new ArgAllowNullAction attribute to allow null to be passed to an action method. This attribute 
            should be attached to an action property.
            </summary>
            <param name="allowNullAction">Whether or not to allow nulls. If true, nulls can be passed. Default is true.</param>
        </member>
        <member name="P:PowerArgs.ArgAllowNullAction.AllowNullAction">
            <summary>
            Whether or not to allow a null to passed to an action method.
            </summary>
        </member>
        <member name="T:PowerArgs.ArgAllowNullActions">
            <summary>
            Use this attribute if you want to allow calling any action with no parameters (even if there are ArgRequired
            or other validation attributes attached the action property's members).
            </summary>
        </member>
        <member name="M:PowerArgs.ArgAllowNullActions.#ctor(System.Boolean)">
            <summary>
            Creates a new ArgAllowNullAction attribute to allow null to be passed to an action method. This attribute
            should be attached to a class.
            </summary>
            <param name="allowNullActions">Whether or not to allow nulls on every action. If true, nulls can be passed. Default is true.</param>
        </member>
        <member name="P:PowerArgs.ArgAllowNullActions.AllowNullActions">
            <summary>
            Whether or not to allow a null to passed to any action method.
            </summary>
        </member>
        <member name="T:PowerArgs.ArgStyleAttribute">
            <summary>
            Obsolete - Don't use this.  Both the -name value and /name:value styles are now both supported automatically.
            </summary>
        </member>
        <member name="M:PowerArgs.ArgStyleAttribute.#ctor(PowerArgs.ArgStyle)">
            <summary>
            Obsolete - Don't use this.  Both the -name value and /name:value styles are now both supported automatically.
            </summary>
            <param name="style">obsolete</param>
        </member>
        <member name="P:PowerArgs.ArgStyleAttribute.Style">
            <summary>
            Obsolete - Don't use this.  Both the -name value and /name:value styles are now both supported automatically.
            </summary>
        </member>
        <member name="T:PowerArgs.ArgIgnoreCase">
            <summary>
            Use this argument on your class or property to enforce case sensitivity.  By default,
            case is ignored.
            </summary>
        </member>
        <member name="M:PowerArgs.ArgIgnoreCase.#ctor(System.Boolean)">
            <summary>
            Create a new ArgIgnoreCase attribute.
            </summary>
            <param name="ignore">Whether or not to ignore case</param>
        </member>
        <member name="P:PowerArgs.ArgIgnoreCase.IgnoreCase">
            <summary>
            Flag to set whether or not case is ignored.
            </summary>
        </member>
        <member name="T:PowerArgs.ArgEnforceCase">
            <summary>
            Use this argument on your class or property to enforce case sensitivity.  By default,
            case is ignored.
            </summary>
        </member>
        <member name="M:PowerArgs.ArgEnforceCase.#ctor">
            <summary>
            Create a new ArgEnforceCase attribute.
            </summary>
        </member>
        <member name="T:PowerArgs.ArgShortcutPolicy">
            <summary>
            An enum to represent argument shortcut policies
            </summary>
        </member>
        <member name="F:PowerArgs.ArgShortcutPolicy.NoShortcut">
            <summary>
            Pass this value to the ArgShortcut attribute's constructor to indicate that the given property
            does not support a shortcut.
            </summary>
        </member>
        <member name="T:PowerArgs.ArgShortcut">
            <summary>
            Use this attribute to override the shortcut that PowerArgs automatically assigns to each property.
            </summary>
        </member>
        <member name="M:PowerArgs.ArgShortcut.#ctor(System.String)">
            <summary>
            Creates a new ArgShortcut attribute with a specified value.
            </summary>
            <param name="shortcut">The value of the new shortcut.</param>
        </member>
        <member name="M:PowerArgs.ArgShortcut.#ctor(PowerArgs.ArgShortcutPolicy)">
            <summary>
            Creates a new ArgShortcut using the given policy
            </summary>
            <param name="policy"></param>
        </member>
        <member name="M:PowerArgs.ArgShortcut.GetShortcut(System.Reflection.PropertyInfo)">
            <summary>
            Get the shortcut value given a property info object.  This can only be called after one of the Args methods
            has parsed the parent type at least once.  Otherwise you will get an InvalidArgDefinitionException.k
            </summary>
            <param name="info">The property whose shortcut you want to get.</param>
            <returns>The shortcut for the property</returns>
        </member>
        <member name="P:PowerArgs.ArgShortcut.Shortcut">
            <summary>
            The shortcut for the given property
            </summary>
        </member>
        <member name="T:PowerArgs.ArgIgnoreAttribute">
            <summary>
            Use this attribute if you want PowerArgs to ignore a property completely.
            </summary>
        </member>
        <member name="T:PowerArgs.ArgPosition">
            <summary>
            Use this attribute if you want users to be able to specify an argument without specifying the name, 
            but rather by it's position on the command line.  All positioned arguments must come before any named arguments.
            Zero '0' represents the first position.  If you are using the Action framework then subcommands must start at
            position 1.
            </summary>
        </member>
        <member name="M:PowerArgs.ArgPosition.#ctor(System.Int32)">
            <summary>
            Creates a new ArgPositionAttribute
            </summary>
            <param name="pos">The expected position of this argument</param>
        </member>
        <member name="P:PowerArgs.ArgPosition.Position">
            <summary>
            The expected position of this argument
            </summary>
        </member>
        <member name="T:PowerArgs.ArgDescription">
            <summary>
            Use this attribute to describe your argument property.  This will show up in the auto generated
            usage documentation.
            
            Optionally, this property can be attached to an action or global class.
            </summary>
        </member>
        <member name="M:PowerArgs.ArgDescription.#ctor(System.String)">
            <summary>
            Creates a new ArgDescription attribute.
            </summary>
            <param name="description">A brief description of your argument property.</param>
        </member>
        <member name="M:PowerArgs.ArgDescription.GetDescription(System.Object)">
            <summary>
            The method used by PowerArgs to retrieve the description.
            Override this if you don't want to attach detailed descriptions in attributes.
            </summary>
            <param name="propertyInfoOrClassType">
            The type for the arguments that are currently being evaluated. Can either by a PropertyType or a class type.
            </param>
            <returns>A brief description of your argument property</returns>
        </member>
        <member name="P:PowerArgs.ArgDescription.Description">
            <summary>
            A brief description of your argument property.
            </summary>
        </member>
        <member name="T:PowerArgs.ArgDetailedDescription">
            <summary>
            Use this attribute to provide extensive details your argument classes.  This will show up in the auto generated
            usage documentation.
            
            Optionally, this property can be attached to an action or global class.
            </summary>
        </member>
        <member name="M:PowerArgs.ArgDetailedDescription.#ctor(System.String)">
            <summary>
            Creates a new ArgDetailedDescription attribute.
            </summary>
            <param name="detailedDescription">A detailed description of your argument class.</param>
        </member>
        <member name="M:PowerArgs.ArgDetailedDescription.GetDetailedDescription(System.Type)">
            <summary>
            The method used by PowerArgs to retrieve the detailed description.
            Override this if you don't want to attach detailed descriptions in attributes.
            </summary>
            <param name="classType">
            The type for the arguments that are currently being evaluated.
            </param>
            <returns>A detailed description of the class of arguments</returns>
        </member>
        <member name="P:PowerArgs.ArgDetailedDescription.DetailedDescription">
            <summary>
            A detailed description of your arguments.
            </summary>
        </member>
        <member name="T:PowerArgs.ArgExample">
            <summary>
            Use this attribute to provide an example of how to use your program.
            </summary>
        </member>
        <member name="M:PowerArgs.ArgExample.#ctor(System.String,System.String)">
            <summary>
            Creates a new ArgExample class
            </summary>
            <param name="example">The example command line.</param>
            <param name="description">A brief description of what this example does.</param>
        </member>
        <member name="P:PowerArgs.ArgExample.Example">
            <summary>
            The example command line.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgExample.Description">
            <summary>
            A brief description of what this example does.
            </summary>
        </member>
        <member name="T:PowerArgs.StickyArg">
            <summary>
            A useful arg hook that will store the last used value for an argument and repeat it the next time.
            </summary>
        </member>
        <member name="M:PowerArgs.StickyArg.#ctor">
            <summary>
            Marks a property as a sticky arg.  Use the default location to store sticky arguments (AppData/Roaming/PowerArgs/EXE_NAME.txt)
            </summary>
        </member>
        <member name="M:PowerArgs.StickyArg.#ctor(System.String)">
            <summary>
            Marks a property as a sticky arg.  Use the provided location to store sticky arguments (AppData/Roaming/PowerArgs/EXE_NAME.txt)
            </summary>
        </member>
        <member name="M:PowerArgs.StickyArg.BeforePopulateProperty(PowerArgs.ArgHook.HookContext)">
            <summary>
            If the user didn't specify a value on the command line then the StickyArg will try to load the last used
            value.
            </summary>
            <param name="Context">Used to see if the property was specified.</param>
        </member>
        <member name="M:PowerArgs.StickyArg.AfterPopulateProperty(PowerArgs.ArgHook.HookContext)">
            <summary>
            If the given property has a non null value then that value is persisted for the next use.
            </summary>
            <param name="Context">Used to see if the property was specified.</param>
        </member>
        <member name="T:PowerArgs.DefaultValueAttribute">
            <summary>
            Use this attribute to set the default value for a parameter.  Note that this only
            works for simple types since only compile time constants can be passed to an attribute.
            </summary>
        </member>
        <member name="M:PowerArgs.DefaultValueAttribute.#ctor(System.Object)">
            <summary>
            Creates a new DefaultValueAttribute with the given value.  Note that the value will get
            converted to a string and then fed into the parser to be revived.
            </summary>
            <param name="value">The default value for the property</param>
        </member>
        <member name="M:PowerArgs.DefaultValueAttribute.BeforePopulateProperty(PowerArgs.ArgHook.HookContext)">
            <summary>
            Before the property is revived and validated, if the user didn't specify a value, 
            then substitue the default value.
            
            </summary>
            <param name="Context"></param>
        </member>
        <member name="P:PowerArgs.DefaultValueAttribute.Value">
            <summary>
            The default value that was specified on the attribute.  Note that the value will get
            converted to a string and then fed into the parser to be revived.
            </summary>
        </member>
        <member name="T:PowerArgs.ConsoleCharacter">
            <summary>
            A wrapper for char that encapsulates foreground and background colors.
            </summary>
        </member>
        <member name="M:PowerArgs.ConsoleCharacter.#ctor(System.Char,System.Nullable{System.ConsoleColor},System.Nullable{System.ConsoleColor})">
            <summary>
            Create a new ConsoleCharacter given a char value and optionally set the foreground or background coor.
            </summary>
            <param name="value">The character value</param>
            <param name="foregroundColor">The foreground color (defaults to the console's foreground color at initialization time).</param>
            <param name="backgroundColor">The background color (defaults to the console's background color at initialization time).</param>
        </member>
        <member name="M:PowerArgs.ConsoleCharacter.Write">
            <summary>
            Write this formatted character to the console
            </summary>
        </member>
        <member name="M:PowerArgs.ConsoleCharacter.ToString">
            <summary>
            Gets the string representation of the character
            </summary>
            <returns></returns>
        </member>
        <member name="M:PowerArgs.ConsoleCharacter.Equals(System.Object)">
            <summary>
            ConsoleCharacters can be compared to other ConsoleCharacter instances or char values.
            </summary>
            <param name="obj">The ConsoleCharacter or char to compare to.</param>
            <returns></returns>
        </member>
        <member name="M:PowerArgs.ConsoleCharacter.op_Equality(PowerArgs.ConsoleCharacter,PowerArgs.ConsoleCharacter)">
            <summary>
            Operator overload for Equals
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
            <returns></returns>
        </member>
        <member name="M:PowerArgs.ConsoleCharacter.op_Inequality(PowerArgs.ConsoleCharacter,PowerArgs.ConsoleCharacter)">
            <summary>
            Operator overload for !Equals
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
            <returns></returns>
        </member>
        <member name="M:PowerArgs.ConsoleCharacter.op_Equality(PowerArgs.ConsoleCharacter,System.Char)">
            <summary>
            Operator overload for Equals
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
            <returns></returns>
        </member>
        <member name="M:PowerArgs.ConsoleCharacter.op_Inequality(PowerArgs.ConsoleCharacter,System.Char)">
            <summary>
            Operator overload for !Equals
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
            <returns></returns>
        </member>
        <member name="M:PowerArgs.ConsoleCharacter.GetHashCode">
            <summary>
            Override of GetHashcode that returns the internal char's hashcode.
            </summary>
            <returns>the internal char's hashcode.</returns>
        </member>
        <member name="P:PowerArgs.ConsoleCharacter.Value">
            <summary>
            The value of the character
            </summary>
        </member>
        <member name="P:PowerArgs.ConsoleCharacter.ForegroundColor">
            <summary>
            The console foreground color to use when printing this character.
            </summary>
        </member>
        <member name="P:PowerArgs.ConsoleCharacter.BackgroundColor">
            <summary>
            The console background color to use when printing this character.
            </summary>
        </member>
        <member name="T:PowerArgs.ConsoleString">
            <summary>
            A wrapper for string that encapsulates foreground and background colors.
            </summary>
        </member>
        <member name="M:PowerArgs.ConsoleString.#ctor">
            <summary>
            Create a new empty ConsoleString
            </summary>
        </member>
        <member name="M:PowerArgs.ConsoleString.#ctor(System.String,System.Nullable{System.ConsoleColor},System.Nullable{System.ConsoleColor})">
            <summary>
            Create a ConsoleString given an initial text value and optional color info.
            </summary>
            <param name="value"></param>
            <param name="foregroundColor">The foreground color (defaults to the console's foreground color at initialization time).</param>
            <param name="backgroundColor">The background color (defaults to the console's background color at initialization time).</param>
        </member>
        <member name="M:PowerArgs.ConsoleString.Append(System.String,System.Nullable{System.ConsoleColor},System.Nullable{System.ConsoleColor})">
            <summary>
            Appends the given value to this ConsoleString using the given formatting.
            </summary>
            <param name="value"></param>
            <param name="foregroundColor">The foreground color (defaults to the console's foreground color at initialization time).</param>
            <param name="backgroundColor">The background color (defaults to the console's background color at initialization time).</param>
        </member>
        <member name="M:PowerArgs.ConsoleString.Append(PowerArgs.ConsoleString)">
            <summary>
            Concatenates two ConsoleStrings together.
            </summary>
            <param name="other">The string to append.</param>
        </member>
        <member name="M:PowerArgs.ConsoleString.AppendUsingCurrentFormat(System.String)">
            <summary>
            Appends the given value using the formatting of the last character or the default formatting if this ConsoleString is empty.
            </summary>
            <param name="value">The string to append.</param>
        </member>
        <member name="M:PowerArgs.ConsoleString.Replace(System.String,System.String,System.Nullable{System.ConsoleColor},System.Nullable{System.ConsoleColor})">
            <summary>
            Replaces all occurrances of the given string with the replacement value using the specified formatting.
            </summary>
            <param name="toFind">The substring to find</param>
            <param name="toReplace">The replacement value</param>
            <param name="foregroundColor">The foreground color (defaults to the console's foreground color at initialization time).</param>
            <param name="backgroundColor">The background color (defaults to the console's background color at initialization time).</param>
            <returns>A new ConsoleString with the replacements.</returns>
        </member>
        <member name="M:PowerArgs.ConsoleString.ReplaceRegex(System.String,System.String,System.Nullable{System.ConsoleColor},System.Nullable{System.ConsoleColor})">
            <summary>
            Replaces all matches of the given regular expression with the replacement value using the specified formatting.
            </summary>
            <param name="regex">The regular expression to find.</param>
            <param name="toReplace">The replacement value</param>
            <param name="foregroundColor">The foreground color (defaults to the console's foreground color at initialization time).</param>
            <param name="backgroundColor">The background color (defaults to the console's background color at initialization time).</param>
            <returns></returns>
        </member>
        <member name="M:PowerArgs.ConsoleString.IndexOf(System.String)">
            <summary>
            Finds the index of a given substring in this ConsoleString.
            </summary>
            <param name="toFind">The substring to search for.</param>
            <returns>The first index of the given substring or -1 if the substring was not found.</returns>
        </member>
        <member name="M:PowerArgs.ConsoleString.Contains(System.String)">
            <summary>
            Determines if this ConsoleString contains the given substring.
            </summary>
            <param name="substr">The substring to search for.</param>
            <returns>True if found, false otherwise.</returns>
        </member>
        <member name="M:PowerArgs.ConsoleString.Substring(System.Int32)">
            <summary>
            Get a substring of this ConsoleString starting at the given index.
            </summary>
            <param name="start">the start index.</param>
            <returns>A new ConsoleString representing the substring requested.</returns>
        </member>
        <member name="M:PowerArgs.ConsoleString.Substring(System.Int32,System.Int32)">
            <summary>
            Get a substring of this ConsoleString starting at the given index and with the given length.
            </summary>
            <param name="start">the start index.</param>
            <param name="length">the number of characters to return</param>
            <returns>A new ConsoleString representing the substring requested.</returns>
        </member>
        <member name="M:PowerArgs.ConsoleString.Write">
            <summary>
            Write this ConsoleString to the console using the desired style.
            </summary>
        </member>
        <member name="M:PowerArgs.ConsoleString.ToString">
            <summary>
            Get the string representation of this ConsoleString.
            </summary>
            <returns></returns>
        </member>
        <member name="M:PowerArgs.ConsoleString.Equals(System.Object)">
            <summary>
            Compare this ConsoleString to another ConsoleString or a plain string.
            </summary>
            <param name="obj">The ConsoleString or plain string to compare to.</param>
            <returns>True if equal, false otherwise</returns>
        </member>
        <member name="M:PowerArgs.ConsoleString.CompareTo(System.String)">
            <summary>
            Compare this ConsoleString to another ConsoleString.
            </summary>
            <param name="other">The ConsoleString to compare to.</param>
            <returns>True if equal, false otherwise</returns>
        </member>
        <member name="M:PowerArgs.ConsoleString.GetHashCode">
            <summary>
            Gets the hashcode of the underlying string
            </summary>
            <returns>the hashcode of the underlying string</returns>
        </member>
        <member name="M:PowerArgs.ConsoleString.op_Addition(PowerArgs.ConsoleString,PowerArgs.ConsoleString)">
            <summary>
            Operator overload that concatenates 2 ConsoleString instances and returns a new one.
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
            <returns>A new, concatenated ConsoleString</returns>
        </member>
        <member name="M:PowerArgs.ConsoleString.op_Addition(PowerArgs.ConsoleString,System.String)">
            <summary>
            Operator overload that concatenates a ConsoleString with a string and returns a new one.
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
            <returns>A new, concatenated ConsoleString</returns>
        </member>
        <member name="M:PowerArgs.ConsoleString.op_Equality(PowerArgs.ConsoleString,PowerArgs.ConsoleString)">
            <summary>
            Compares 2 ConsoleStrings for equality.
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
            <returns>True if they are the same, false otherwise</returns>
        </member>
        <member name="M:PowerArgs.ConsoleString.op_Inequality(PowerArgs.ConsoleString,PowerArgs.ConsoleString)">
            <summary>
            Compares 2 ConsoleStrings for inequality.
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
            <returns>False if they are the same, true otherwise</returns>
        </member>
        <member name="P:PowerArgs.ConsoleString.Empty">
            <summary>
            Represents an empty string.  You will get a new instance each time you access this property.
            </summary>
        </member>
        <member name="P:PowerArgs.ConsoleString.Length">
            <summary>
            The length of the string.
            </summary>
        </member>
        <member name="T:PowerArgs.Args">
            <summary>
            The main entry point for PowerArgs that includes the public parsing functions such as Parse, ParseAction, and InvokeAction.
            </summary>
        </member>
        <member name="M:PowerArgs.Args.ParseAction``1(System.String[])">
            <summary>
            Creates a new instance of T and populates it's properties based on the given arguments.
            If T correctly implements the heuristics for Actions (or sub commands) then the complex property
            that represents the options of a sub command are also populated.
            </summary>
            <typeparam name="T">The argument scaffold type.</typeparam>
            <param name="args">The command line arguments to parse</param>
            <returns>The raw result of the parse with metadata about the specified action.</returns>
        </member>
        <member name="M:PowerArgs.Args.ParseAction(System.Type,System.String[])">
            <summary>
            Creates a new instance of the given type and populates it's properties based on the given arguments.
            If the type correctly implements the heuristics for Actions (or sub commands) then the complex property
            that represents the options of a sub command are also populated.
            </summary>
            <param name="t">The argument scaffold type.</param>
            <param name="args">The command line arguments to parse</param>
            <returns>The raw result of the parse with metadata about the specified action.</returns>
        </member>
        <member name="M:PowerArgs.Args.InvokeAction``1(System.String[])">
            <summary>
            Creates a new instance of T and populates it's properties based on the given arguments. T must correctly
            implement the heuristics for Actions (or sub commands) because this method will not only detect the action
            specified on the command line, but will also find and execute the method that implements the action.
            </summary>
            <typeparam name="T">The argument scaffold type that must properly implement at least one action.</typeparam>
            <param name="args">The command line arguments to parse</param>
            <returns>The raw result of the parse with metadata about the specified action.  The action is executed before returning.</returns>
        </member>
        <member name="M:PowerArgs.Args.Parse``1(System.String[])">
            <summary>
            Creates a new instance of T and populates it's properties based on the given arguments.
            </summary>
            <typeparam name="T">The argument scaffold type.</typeparam>
            <param name="args">The command line arguments to parse</param>
            <returns>A new instance of T with all of the properties correctly populated</returns>
        </member>
        <member name="M:PowerArgs.Args.Parse(System.Type,System.String[])">
            <summary>
            Creates a new instance of the given type and populates it's properties based on the given arguments.
            </summary>
            <param name="t">The argument scaffold type</param>
            <param name="args">The command line arguments to parse</param>
            <returns>A new instance of the given type with all of the properties correctly populated</returns>
        </member>
        <member name="T:PowerArgs.ArgStyle">
            <summary>
            Obsolete, both the -name value and /name:value styles are supported automatically.
            </summary>
        </member>
        <member name="F:PowerArgs.ArgStyle.PowerShell">
            <summary>
            Obsolete, both the -name value and /name:value styles are supported automatically.
            </summary>
        </member>
        <member name="F:PowerArgs.ArgStyle.SlashColon">
            <summary>
            Obsolete, both the -name value and /name:value styles are supported automatically.
            </summary>
        </member>
        <member name="T:PowerArgs.ParseResult">
            <summary>
            The raw parse result that contains the dictionary of values that were parsed
            </summary>
        </member>
        <member name="P:PowerArgs.ParseResult.ExplicitParameters">
            <summary>
            Dictionary of values that were either in the format -key value or /key:value on
            the command line.
            </summary>
        </member>
        <member name="P:PowerArgs.ParseResult.ImplicitParameters">
            <summary>
            Dictionary of values that were implicitly specified by position where the key is the position (e.g. 0)
            and the value is the actual parameter value.
            
            Example command line:  Program.exe John Smith
            
            John would be an implicit parameter at position 0.
            Smith would be an implicit parameter at position 1.
            </summary>
        </member>
        <member name="T:PowerArgs.ArgUsageOptions">
            <summary>
            A class that lets you customize how your usage displays
            </summary>
        </member>
        <member name="M:PowerArgs.ArgUsageOptions.#ctor">
            <summary>
            Creates a new instance of ArgUsageOptions
            </summary>
        </member>
        <member name="P:PowerArgs.ArgUsageOptions.ShowType">
            <summary>
            Set to true if you want to show the type column (true by default)
            </summary>
        </member>
        <member name="P:PowerArgs.ArgUsageOptions.ShowPosition">
            <summary>
            Set to true if you want to show the position column (true by default)
            </summary>
        </member>
        <member name="P:PowerArgs.ArgUsageOptions.ShowColumnHeaders">
            <summary>
            Set to true print the column headers on the usage output (true by default).
            </summary>
        </member>
        <member name="P:PowerArgs.ArgUsageOptions.CompactFormat">
            <summary>
            Set to true to reduce the padding and linebreaks output (false by default).
            </summary>
        </member>
        <member name="P:PowerArgs.ArgUsageOptions.ShortcutThenName">
            <summary>
            Set to true to print the shortcuts first, followed by the full argument names (false by default).
            </summary>
        </member>
        <member name="P:PowerArgs.ArgUsageOptions.NoOptionsMessage">
            <summary>
            The message displayed when no options are found (string.Empty by default).
            </summary>
        </member>
        <member name="T:PowerArgs.UsageHook">
            <summary>
            An attribute used to hook into the usage generation process and influence
            the content that is written.
            </summary>
        </member>
        <member name="M:PowerArgs.UsageHook.BeforeGenerateUsage(PowerArgs.ArgumentUsageInfo)">
            <summary>
            This hook gets called when the property it is attached to is having
            its usage generated.  You can override this method and manipulate the
            properties of the given usage info object.
            </summary>
            <param name="info">An object that you can use to manipulate the usage output.</param>
        </member>
        <member name="E:PowerArgs.UsageHook.HookExecuting">
            <summary>
            An event you can subscribe to in the case where you created
            your hook in running code rather than as a declarative attribute.
            </summary>
        </member>
        <member name="T:PowerArgs.ArgumentUsageInfo">
            <summary>
            A class that represents usage info to be written to the console.
            </summary>
        </member>
        <member name="M:PowerArgs.ArgumentUsageInfo.#ctor(System.Reflection.PropertyInfo)">
            <summary>
            Generate a new info instance given a reflected property. 
            </summary>
            <param name="toAutoGen">The property to use to seed the usage info</param>
        </member>
        <member name="P:PowerArgs.ArgumentUsageInfo.Name">
            <summary>
            The name that will be written as part of the usage.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgumentUsageInfo.Aliases">
            <summary>
            Aliases for this argument that will be honored by the parser.  This
            includes shortcuts and long form aliases, but can be extended further.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgumentUsageInfo.IsRequired">
            <summary>
            Indicates that the argument is required.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgumentUsageInfo.Type">
            <summary>
            The friendly type name that will be displayed to the user.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgumentUsageInfo.Position">
            <summary>
            The expected position of the argument, or null if not a positioning is not supported for the given argument.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgumentUsageInfo.Description">
            <summary>
            The description that will be written as part of the usage.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgumentUsageInfo.Ignore">
            <summary>
            If set to true, the argument usage will not be written.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgumentUsageInfo.IsAction">
            <summary>
            True if this is the "Action" property
            </summary>
        </member>
        <member name="P:PowerArgs.ArgumentUsageInfo.IsActionArgs">
            <summary>
            True if this represents a nested action argument property
            </summary>
        </member>
        <member name="P:PowerArgs.ArgumentUsageInfo.Property">
            <summary>
            The reflected property that this info object represents
            </summary>
        </member>
        <member name="T:PowerArgs.ArgUsage">
            <summary>
            A helper class that generates usage documentation for your command line arguments given a custom argument
            scaffolding type.
            </summary>
        </member>
        <member name="M:PowerArgs.ArgUsage.RegisterHook(System.Reflection.PropertyInfo,PowerArgs.UsageHook)">
            <summary>
            Registers a usage hook for the given property.
            </summary>
            <param name="prop">The property to hook into or null to hook into all properties.</param>
            <param name="hook">The hook implementation.</param>
        </member>
        <member name="M:PowerArgs.ArgUsage.GetUsage``1(System.String,PowerArgs.ArgUsageOptions,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Generates usage documentation for the given argument scaffold type.
            </summary>
            <typeparam name="T">Your custom argument scaffold type</typeparam>
            <param name="exeName">The name of your program or null if you want PowerArgs to automatically detect it.</param>
            <param name="options">Specify custom usage options</param>
            <returns></returns>
        </member>
        <member name="M:PowerArgs.ArgUsage.GetStyledUsage``1(System.String,PowerArgs.ArgUsageOptions,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Generates color styled usage documentation for the given argument scaffold type.  
            </summary>
            <typeparam name="T">Your custom argument scaffold type</typeparam>
            <param name="exeName">The name of your program or null if you want PowerArgs to automatically detect it.</param>
            <param name="options">Specify custom usage options</param>
            <param name="singleAction"></param>
            <returns></returns>
        </member>
        <member name="M:PowerArgs.ArgUsage.GetStyledUsage(System.Type,System.String,PowerArgs.ArgUsageOptions,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Generates color styled usage documentation for the given argument scaffold type.  
            </summary>
            <param name="Type">Your custom argument scaffold type</param>
            <param name="exeName">The name of your program or null if you want PowerArgs to automatically detect it.</param>
            <param name="options">Specify custom usage options</param>
            <returns></returns>
        </member>
        <member name="T:PowerArgs.ArgException">
            <summary>
            An exception that should be thrown when the error condition is caused because of bad user input.
            </summary>
        </member>
        <member name="M:PowerArgs.ArgException.#ctor(System.String)">
            <summary>
            Creates a new ArgException given a user friendly message
            </summary>
            <param name="msg">A user friendly message.</param>
        </member>
        <member name="M:PowerArgs.ArgException.#ctor(System.String,System.Exception)">
            <summary>
            Creates a new ArgException given a user friendly message
            </summary>
            <param name="msg">A user friendly message.</param>
            <param name="inner">The inner exception that caused the problem</param>
        </member>
        <member name="P:PowerArgs.ArgException.Action">
            <summary>
            If the processing of the arguments has proceed past the stage of determining what action 
            (if any) was issued, this field will hold the action that was parsed.
            </summary>
        </member>
        <member name="T:PowerArgs.InvalidArgDefinitionException">
            <summary>
            An exception that should be thrown when the error condition is caused by an improperly formed
            argument scaffold type.  For example if the user specified the same shortcut value for more than one property.
            </summary>
        </member>
        <member name="M:PowerArgs.InvalidArgDefinitionException.#ctor(System.String)">
            <summary>
            Creates a new InvalidArgDefinitionException given a message.
            </summary>
            <param name="msg">An error message.</param>
        </member>
        <member name="M:PowerArgs.InvalidArgDefinitionException.#ctor(System.String,System.Exception)">
            <summary>
            Creates a new InvalidArgDefinitionException given a message.
            </summary>
            <param name="msg">An error message.</param>
            <param name="inner">The inner exception that caused the problem</param>
        </member>
        <member name="T:PowerArgs.UnexpectedArgException">
            <summary>
            An exception that should be thrown when an unexpected named|positional argument is found.
            </summary>
        </member>
        <member name="M:PowerArgs.UnexpectedArgException.#ctor(System.String)">
            <summary>
            Creates a new UnexpectedArgException given a user friendly message
            </summary>
            <param name="msg">A user friendly message.</param>
        </member>
        <member name="M:PowerArgs.UnexpectedArgException.#ctor(System.String,System.Exception)">
            <summary>
            Creates a new UnexpectedArgException given a user friendly message
            </summary>
            <param name="msg">A user friendly message.</param>
            <param name="inner">The inner exception that caused the problem</param>
        </member>
        <member name="T:PowerArgs.DuplicateArgException">
            <summary>
            An exception that should be thrown when the same argument is repeated.
            </summary>
        </member>
        <member name="M:PowerArgs.DuplicateArgException.#ctor(System.String)">
            <summary>
            Creates a new DuplicateArgException given a user friendly message
            </summary>
            <param name="msg">A user friendly message.</param>
        </member>
        <member name="M:PowerArgs.DuplicateArgException.#ctor(System.String,System.Exception)">
            <summary>
            Creates a new DuplicateArgException given a user friendly message
            </summary>
            <param name="msg">A user friendly message.</param>
            <param name="inner">The inner exception that caused the problem</param>
        </member>
        <member name="T:PowerArgs.MissingArgException">
            <summary>
            An exception that should be thrown when a required argument is missing.
            </summary>
        </member>
        <member name="M:PowerArgs.MissingArgException.#ctor(System.String)">
            <summary>
            Creates a new MissingArgException given a user friendly message
            </summary>
            <param name="msg">A user friendly message.</param>
        </member>
        <member name="M:PowerArgs.MissingArgException.#ctor(System.String,System.Exception)">
            <summary>
            Creates a new MissingArgException given a user friendly message
            </summary>
            <param name="msg">A user friendly message.</param>
            <param name="inner">The inner exception that caused the problem</param>
        </member>
        <member name="T:PowerArgs.UnknownActionArgException">
            <summary>
            An exception that should be thrown when an unknown action argument is specified.
            </summary>
        </member>
        <member name="M:PowerArgs.UnknownActionArgException.#ctor(System.String)">
            <summary>
            Creates a new UnknownActionArgException given a user friendly message
            </summary>
            <param name="msg">A user friendly message.</param>
        </member>
        <member name="M:PowerArgs.UnknownActionArgException.#ctor(System.String,System.Exception)">
            <summary>
            Creates a new UnknownActionArgException given a user friendly message
            </summary>
            <param name="msg">A user friendly message.</param>
            <param name="inner">The inner exception that caused the problem</param>
        </member>
        <member name="T:PowerArgs.QueryInvalidArgException">
            <summary>
            An exception that should be thrown when the query can not be compiled.
            </summary>
        </member>
        <member name="M:PowerArgs.QueryInvalidArgException.#ctor(System.String)">
            <summary>
            Creates a new QueryInvalidArgException given a user friendly message
            </summary>
            <param name="msg">A user friendly message.</param>
        </member>
        <member name="M:PowerArgs.QueryInvalidArgException.#ctor(System.String,System.Exception)">
            <summary>
            Creates a new QueryInvalidArgException given a user friendly message
            </summary>
            <param name="msg">A user friendly message.</param>
            <param name="inner">The inner exception that caused the problem</param>
        </member>
        <member name="T:PowerArgs.ValidationArgException">
            <summary>
            An exception that should be thrown when an argument's value is not valid.
            </summary>
        </member>
        <member name="M:PowerArgs.ValidationArgException.#ctor(System.String)">
            <summary>
            Creates a new ValidationArgException given a user friendly message
            </summary>
            <param name="msg">A user friendly message.</param>
        </member>
        <member name="M:PowerArgs.ValidationArgException.#ctor(System.String,System.Exception)">
            <summary>
            Creates a new ValidationArgException given a user friendly message
            </summary>
            <param name="msg">A user friendly message.</param>
            <param name="inner">The inner exception that caused the problem</param>
        </member>
        <member name="T:PowerArgs.GroupedRegexArg">
            <summary>
            An abstract class that lets you create custom argument types that match a regular expression.  The 
            class also makes it easy to extract named groups from the regular expression for use by your application.
            </summary>
        </member>
        <member name="F:PowerArgs.GroupedRegexArg.exactMatch">
            <summary>
            The match that exactly matches the given regular expression
            </summary>
        </member>
        <member name="M:PowerArgs.GroupedRegexArg.#ctor(System.String,System.String,System.String)">
            <summary>
            Creates a new grouped regular expression argument instance.
            </summary>
            <param name="regex">The regular expression to enforce</param>
            <param name="input">The user input that was provided</param>
            <param name="errorMessage">An error message to show in the case of a non match</param>
        </member>
        <member name="M:PowerArgs.GroupedRegexArg.Group(System.String,System.String)">
            <summary>
            A helper function you can use to group a particular regular expression.
            </summary>
            <param name="regex">Your regular expression that you would like to put in a group.</param>
            <param name="groupName">The name of the group that you can use to extract the group value later.</param>
            <returns></returns>
        </member>
        <member name="P:PowerArgs.GroupedRegexArg.Item(System.String)">
            <summary>
            Gets the value of the regex group from the exact match.
            </summary>
            <param name="groupName">The name of the group to lookup</param>
            <returns></returns>
        </member>
        <member name="P:PowerArgs.GroupedRegexArg.Item(System.Int32)">
            <summary>
            Gets the value of the regex group from the exact match.
            </summary>
            <param name="groupNumber">The index of the group to lookup</param>
            <returns></returns>
        </member>
        <member name="T:PowerArgs.USPhoneNumber">
            <summary>
            An example of a custom type that uses regular expressions to extract values from the command line
            and implements an ArgReviver to transform the text input into a complex type.
            This class represents a US phone number.
            </summary>
        </member>
        <member name="M:PowerArgs.USPhoneNumber.#ctor(System.String)">
            <summary>
            Creates a phone number object from a string
            </summary>
            <param name="phoneNumber"></param>
        </member>
        <member name="M:PowerArgs.USPhoneNumber.ToString">
            <summary>
            Gets the default string representation of the phone number in the format '1-(aaa)-bbb-cccc'.
            </summary>
            <returns></returns>
        </member>
        <member name="M:PowerArgs.USPhoneNumber.ToString(System.String)">
            <summary>
            Formats the phone number as a string.  
            </summary>
            <param name="format">Use '{aaa}' for the area code, use {bbb} for the first grouping, and use {cccc} for the second grouping.</param>
            <returns>A formatted phone number string</returns>
        </member>
        <member name="M:PowerArgs.USPhoneNumber.Revive(System.String,System.String)">
            <summary>
            Custom PowerArgs reviver that converts a string parameter into a custom phone number
            </summary>
            <param name="key">The name of the argument (not used)</param>
            <param name="val">The value specified on the command line</param>
            <returns>A USPhoneNumber object based on the user input</returns>
        </member>
        <member name="P:PowerArgs.USPhoneNumber.AreaCode">
            <summary>
            The three digit area code of the phone number.
            </summary>
        </member>
        <member name="P:PowerArgs.USPhoneNumber.FirstDigits">
            <summary>
            The three digit first segment of the phone number
            </summary>
        </member>
        <member name="P:PowerArgs.USPhoneNumber.SecondDigits">
            <summary>
            The four digit second segment of the phone number.
            </summary>
        </member>
        <member name="T:PowerArgs.ArgValidator">
            <summary>
            An abstract class that all validators should extend to validate user input from the command line.
            </summary>
        </member>
        <member name="M:PowerArgs.ArgValidator.Validate(System.String,System.String@)">
            <summary>
            Most validators should just override this method. It ONLY gets called if the user specified the 
            given argument on the command line, meaning you will never get a null for 'arg'.
            
            If you want your validator to run even if the user did not specify the argument on the command line
            (for example if you were building something like [ArgRequired] then you should do 3 things.
            
            1 - Override the boolean ImplementsValidateAlways property so that it returns true
            2 - Override the ValidateAlways() method instead
            3 - Don't override the Validate() method since it will no longer be called
            
            </summary>
            <param name="name"></param>
            <param name="arg">The value specified on the command line.  If the user specified the property name, but not a value then arg will equal string.Empty.  The value will never be null.</param>
        </member>
        <member name="M:PowerArgs.ArgValidator.ValidateAlways(System.Reflection.PropertyInfo,System.String@)">
             <summary>
             Always validates the given property, even if it was not specified by the user (arg will be null in this case).
             If you override this method then you should also override ImplementsValidateAlways so it returns true.
            </summary>
             <param name="property">The property that the attribute was placed on.</param>
             <param name="arg">The value specified on the command line or null if the user didn't actually specify a value for the property.  If the user specified the property name, but not a value then arg will equal string.Empty</param>
        </member>
        <member name="P:PowerArgs.ArgValidator.Priority">
            <summary>
            Determines the order in which validators are executed.  Higher numbers execute first.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgValidator.ImplementsValidateAlways">
            <summary>
            If implemented in a derived class then ValidateAlways will be called for each property,
            even if that property wasn't specified by the user on the command line.  In this case the value
            will always be null.  This is useful for implementing validators such as [ArgRequired].
            
            By default, the Validate(string,ref string) method is called unless a validator opts into ValidateAlways
            </summary>
        </member>
        <member name="T:PowerArgs.IArgClassValidator">
            <summary>
            A validator that validates an entire args object.
            </summary>
        </member>
        <member name="M:PowerArgs.IArgClassValidator.Validate">
            <summary>
            A validation method that should throw an exception if any instance member is not valid.
            This validation check occurs after the standard validation mechanism
            </summary>
        </member>
        <member name="T:PowerArgs.ArgExistingFile">
            <summary>
            Validates that if the user specifies a value for a property that the value represents a file that exists
            as determined by System.IO.File.Exists(file).
            </summary>
        </member>
        <member name="M:PowerArgs.ArgExistingFile.Validate(System.String,System.String@)">
            <summary>
            Validates that the given file exists and cleans up the argument so that the application has access
            to the full path.
            </summary>
            <param name="name">the name of the property being populated.  This validator doesn't do anything with it.</param>
            <param name="arg">The value specified on the command line</param>
        </member>
        <member name="T:PowerArgs.ArgExistingDirectory">
            <summary>
            Validates that if the user specifies a value for a property that the value represents a directory that exists
            as determined by System.IO.Directory.Exists(directory).
            </summary>
        </member>
        <member name="M:PowerArgs.ArgExistingDirectory.Validate(System.String,System.String@)">
            <summary>
            Validates that the given directory exists and cleans up the argument so that the application has access
            to the full path.
            </summary>
            <param name="name">the name of the property being populated.  This validator doesn't do anything with it.</param>
            <param name="arg">The value specified on the command line</param>
        </member>
        <member name="T:PowerArgs.ArgRange">
            <summary>
            Validates that the value is a number between the min and max (both inclusive) specified
            </summary>
        </member>
        <member name="M:PowerArgs.ArgRange.#ctor(System.Double,System.Double)">
            <summary>
             Creates a new ArgRange validator.
            </summary>
            <param name="min">The minimum value (inclusive)</param>
            <param name="max">The maximum value (inclusive by default, set MaxIsExclusive to true to override)</param>
        </member>
        <member name="M:PowerArgs.ArgRange.Validate(System.String,System.String@)">
            <summary>
            Validates that the value is a number between the min and max (both inclusive) specifie
            </summary>
            <param name="name">the name of the property being populated.  This validator doesn't do anything with it.</param>
            <param name="arg">The value specified on the command line</param>
        </member>
        <member name="P:PowerArgs.ArgRange.MaxIsExclusive">
            <summary>
            Set to true if your max is exclusive.  This value is false by default.
            </summary>
        </member>
        <member name="T:PowerArgs.ArgRequired">
            <summary>
            Validates that the user actually provided a value for the given property on the command line.
            </summary>
        </member>
        <member name="M:PowerArgs.ArgRequired.#ctor">
            <summary>
            Creates a new ArgRequired attribute.
            </summary>
        </member>
        <member name="M:PowerArgs.ArgRequired.ValidateAlways(System.Reflection.PropertyInfo,System.String@)">
            <summary>
            Validates that the user actually specified a value and optionally prompts them when it is missing.
            </summary>
            <param name="prop">The property being populated.  This validator doesn't do anything with it.</param>
            <param name="arg">The value specified on the command line or null if it wasn't specified</param>
        </member>
        <member name="P:PowerArgs.ArgRequired.ImplementsValidateAlways">
            <summary>
            Determines whether or not the validator should run even if the user doesn't specify a value on the command line.
            This value is always true for this validator.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgRequired.PromptIfMissing">
            <summary>
            If you set this to true and the user didn't specify a value then the command line will prompt the user for the value.
            </summary>
        </member>
        <member name="T:PowerArgs.ArgRegex">
            <summary>
            Performs regular expression validation on a property.
            </summary>
        </member>
        <member name="F:PowerArgs.ArgRegex.regex">
            <summary>
            The regular expression to match
            </summary>
        </member>
        <member name="F:PowerArgs.ArgRegex.errorMessage">
            <summary>
            A prefix for the error message to show in the case of a match.
            </summary>
        </member>
        <member name="F:PowerArgs.ArgRegex.exactMatch">
            <summary>
            The exact match that was found.
            </summary>
        </member>
        <member name="M:PowerArgs.ArgRegex.#ctor(System.String,System.String)">
            <summary>
            Creates a new ArgRegex validator.
            </summary>
            <param name="regex">The regular expression that requires an exact match to be valid</param>
            <param name="errorMessage">A prefix for the error message to show in the case of a match.</param>
        </member>
        <member name="M:PowerArgs.ArgRegex.Validate(System.String,System.String@)">
            <summary>
            Validates that the given arg exactly matches the regular expression provided.
            </summary>
            <param name="name">the name of the property being populated.  This validator doesn't do anything with it.</param>
            <param name="arg">The value specified on the command line.</param>
        </member>
        <member name="T:PowerArgs.Query">
            <summary>
            A hook you can use to easily query a data source.  See an example here: https://github.com/adamabdelhamed/PowerArgs#data-source-queries
            </summary>
        </member>
        <member name="M:PowerArgs.Query.#ctor(System.Type,System.String[])">
            <summary>
            Creates a new query hook given a data source type and optional reference assemblies.
            </summary>
            <param name="dataSourceType">Your data source implementation. he query will create a new instance of this type and use a property that matches the property name of the PowerArgs property this attribute is on in order to get the data.</param>
            <param name="referencedAssemblies">The names (if in the GAC) or full paths to assemblies you would like to include.  We will automatically add dlls in your bin folder.</param>
        </member>
        <member name="M:PowerArgs.Query.AfterPopulateProperties(PowerArgs.ArgHook.HookContext)">
            <summary>
            After PowerArgs does most of its work this hook looks for string properties on the parsed object called Skip, Take, 
            Where, OrderBy, and OrderByDescending.  These properties are used to construct a linq query that is dynamically compiled
            and executed against the provided data source.
            </summary>
            <param name="context">The context used to detect the query parameters.</param>
        </member>
        <member name="P:PowerArgs.Query.DataSourceType">
            <summary>
            Your data source implementation.  The query will create a new instance of this type and use a property
            that matches the property name of the PowerArgs property this attribute is on in order to get the data.
            </summary>
        </member>
        <member name="T:PowerArgs.Resources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:PowerArgs.Resources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:PowerArgs.Resources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:PowerArgs.Resources.QueryTemplate">
             <summary>
               Looks up a localized string similar to using System;
            using System.Linq;
            using System.Collections.Generic;
            $Usings$
            
            namespace $Namespace$
            {
                public class $Class$
                {
                    public static List&lt;$ReturnType$&gt; $Method$(IEnumerable&lt;$ReturnType$&gt; source)
                    {
                        IEnumerable&lt;$ReturnType$&gt; query = from item in source select item;
            
                        $WhereComment$              query = from item in query where $Where$ select item;
                        $OrderByDescendingComment$  query = query.OrderByDescending($OrderByDescending$);
                [rest of string was truncated]&quot;;.
             </summary>
        </member>
        <member name="T:PowerArgs.SecureStringArgument">
            <summary>
            A PowerArgs argument type that can be used to accept user input without that input appearing on the command line.
            It uses secure strings under the hood.
            </summary>
        </member>
        <member name="M:PowerArgs.SecureStringArgument.ConvertToNonsecureString">
            <summary>
            Converts the underlying secure string to a regular string.
            </summary>
            <returns>A normal string representation of the user's input.</returns>
        </member>
        <member name="P:PowerArgs.SecureStringArgument.SecureString">
            <summary>
            The secure string value.  The first time your code accesses this property is when the user will be presented with
            the secure input prompt.
            </summary>
        </member>
        <member name="T:PowerArgs.TabCompletion">
            <summary>
            A hook that takes over the command line and provides tab completion for known strings when the user presses
            the tab key.
            </summary>
        </member>
        <member name="M:PowerArgs.TabCompletion.#ctor(System.String)">
            <summary>
            Creates a new tab completion hook.
            </summary>
            <param name="indicator">When this indicator is the only argument the user specifies that triggers the hook to enhance the command prompt.  By default, the indicator is the empty string.</param>
        </member>
        <member name="M:PowerArgs.TabCompletion.#ctor(System.Type,System.String)">
            <summary>
            Creates a new tab completion hook given a custom tab completion implementation.
            </summary>
            <param name="completionSource">A type that implements ITabCompletionSource such as SimpleTabCompletionSource</param>
            <param name="indicator">When this indicator is the only argument the user specifies that triggers the hook to enhance the command prompt.  By default, the indicator is the empty string.</param>
        </member>
        <member name="M:PowerArgs.TabCompletion.BeforeParse(PowerArgs.ArgHook.HookContext)">
            <summary>
            Before PowerArgs parses the args, this hook inspects the command line for the indicator and if found 
            takes over the command line and provides tab completion.
            </summary>
            <param name="context">The context used to inspect the command line arguments.</param>
        </member>
        <member name="M:PowerArgs.TabCompletion.ClearHistory">
            <summary>
            Clears all history saved on disk
            </summary>
        </member>
        <member name="P:PowerArgs.TabCompletion.HistoryToSave">
            <summary>
            If this is > 0 then PowerArgs will save this many previous executions of the command line to your application data folder.
            Users can then access the history by pressing arrow up or down from the enhanced command prompt.
            </summary>
        </member>
        <member name="P:PowerArgs.TabCompletion.HistoryFileName">
            <summary>
            The location of the history file name (AppData/PowerArgs/EXE_NAME.TabCompletionHistory.txt
            </summary>
        </member>
        <member name="P:PowerArgs.TabCompletion.ExeName">
            <summary>
            The name of your program (leave null and PowerArgs will try to detect it automatically)
            </summary>
        </member>
        <member name="T:PowerArgs.ITabCompletionSource">
            <summary>
            An interface used to implement custom tab completion logic.
            </summary>
        </member>
        <member name="M:PowerArgs.ITabCompletionSource.TryComplete(System.Boolean,System.String,System.String@)">
            <summary>
            PowerArgs will call this method if it has enhanced the command prompt and the user presses tab.  You should use the
            text the user has types so far to determine if there is a completion you'd like to make.  If you find a completion
            then you should assign it to the completion variable and return true.
            </summary>
            <param name="shift">Indicates if shift was being pressed</param>
            <param name="soFar">The text token that the user has typed before pressing tab.</param>
            <param name="completion">The variable that you should assign the completed string to if you find a match.</param>
            <returns>True if you completed the string, false otherwise.</returns>
        </member>
        <member name="T:PowerArgs.MultiTabCompletionSource">
            <summary>
            An aggregate tab completion source that cycles through it's inner sources looking for matches.
            </summary>
        </member>
        <member name="M:PowerArgs.MultiTabCompletionSource.#ctor(PowerArgs.ITabCompletionSource[])">
            <summary>
            Create a new MultiTabCompletionSource given an array of sources.
            </summary>
            <param name="sources">The sources to wrap</param>
        </member>
        <member name="M:PowerArgs.MultiTabCompletionSource.#ctor(System.Collections.Generic.IEnumerable{PowerArgs.ITabCompletionSource})">
            <summary>
            Create a new MultiTabCompletionSource given an IEnumerable of sources.
            </summary>
            <param name="sources">The sources to wrap</param>
        </member>
        <member name="M:PowerArgs.MultiTabCompletionSource.TryComplete(System.Boolean,System.String,System.String@)">
            <summary>
            Iterates over the wrapped sources looking for a match
            </summary>
            <param name="shift">Indicates if shift was being pressed</param>
            <param name="soFar">The text token that the user has typed before pressing tab.</param>
            <param name="completion">The variable that you should assign the completed string to if you find a match.</param>
            <returns></returns>
        </member>
        <member name="T:PowerArgs.SimpleTabCompletionSource">
            <summary>
            A simple tab completion source implementation that looks for matches over a set of pre-determined strings.
            </summary>
        </member>
        <member name="M:PowerArgs.SimpleTabCompletionSource.#ctor(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Creates a new completion source given an enumeration of string candidates
            </summary>
            <param name="candidates"></param>
        </member>
        <member name="M:PowerArgs.SimpleTabCompletionSource.TryComplete(System.Boolean,System.String,System.String@)">
            <summary>
            Iterates through the candidates to try to find a match.  If there are multiple possible matches it 
            supports cycling through tem as the user continually presses tab.
            </summary>
            <param name="shift">Indicates if shift was being pressed</param>
            <param name="soFar">The text token that the user has typed before pressing tab.</param>
            <param name="completion">The variable that you should assign the completed string to if you find a match.</param>
            <returns></returns>
        </member>
        <member name="P:PowerArgs.SimpleTabCompletionSource.MinCharsBeforeCyclingBegins">
            <summary>
            Require that the user type this number of characters before the source starts cycling through ambiguous matches.  The default is 3.
            </summary>
        </member>
        <member name="T:PowerArgs.ConsoleHelper">
            <summary>
            Used for internal implementation, but marked public for testing, please do not use.
            </summary>
        </member>
        <member name="F:PowerArgs.ConsoleHelper.ConsoleImpl">
            <summary>
            Used for internal implementation, but marked public for testing, please do not use.
            </summary>
        </member>
        <member name="T:PowerArgs.ConsoleHelper.IConsoleProvider">
            <summary>
            Used for internal implementation, but marked public for testing, please do not use.
            </summary>
        </member>
        <member name="M:PowerArgs.ConsoleHelper.IConsoleProvider.ReadKey">
            <summary>
            Used for internal implementation, but marked public for testing, please do not use.
            </summary>
        </member>
        <member name="M:PowerArgs.ConsoleHelper.IConsoleProvider.Write(System.Object)">
            <summary>
            Used for internal implementation, but marked public for testing, please do not use.
            </summary>
        </member>
        <member name="M:PowerArgs.ConsoleHelper.IConsoleProvider.WriteLine(System.Object)">
            <summary>
            Used for internal implementation, but marked public for testing, please do not use.
            </summary>
        </member>
        <member name="M:PowerArgs.ConsoleHelper.IConsoleProvider.WriteLine">
            <summary>
            Used for internal implementation, but marked public for testing, please do not use.
            </summary>
        </member>
        <member name="P:PowerArgs.ConsoleHelper.IConsoleProvider.CursorLeft">
            <summary>
            Used for internal implementation, but marked public for testing, please do not use.
            </summary>
        </member>
        <member name="T:PowerArgs.ConsoleHelper.StdConsoleProvider">
            <summary>
            Used for internal implementation, but marked public for testing, please do not use.
            </summary>
        </member>
        <member name="M:PowerArgs.ConsoleHelper.StdConsoleProvider.ReadKey">
            <summary>
            Used for internal implementation, but marked public for testing, please do not use.
            </summary>
            <returns>Used for internal implementation, but marked public for testing, please do not use.</returns>
        </member>
        <member name="M:PowerArgs.ConsoleHelper.StdConsoleProvider.Write(System.Object)">
            <summary>
            Used for internal implementation, but marked public for testing, please do not use.
            </summary>
            <param name="output">Used for internal implementation, but marked public for testing, please do not use.</param>
        </member>
        <member name="M:PowerArgs.ConsoleHelper.StdConsoleProvider.WriteLine(System.Object)">
            <summary>
            Used for internal implementation, but marked public for testing, please do not use.
            </summary>
            <param name="output">Used for internal implementation, but marked public for testing, please do not use.</param>
        </member>
        <member name="M:PowerArgs.ConsoleHelper.StdConsoleProvider.WriteLine">
            <summary>
            Used for internal implementation, but marked public for testing, please do not use.
            </summary>
        </member>
        <member name="M:PowerArgs.ConsoleHelper.StdConsoleProvider.ReadALineOfConsoleOutput(System.Int32)">
            <summary>
            Used for internal implementation, but marked public for testing, please do not use.
            </summary>
            <param name="y">Used for internal implementation, but marked public for testing, please do not use.</param>
            <returns>Used for internal implementation, but marked public for testing, please do not use.</returns>
        </member>
        <member name="P:PowerArgs.ConsoleHelper.StdConsoleProvider.CursorLeft">
            <summary>
            Used for internal implementation, but marked public for testing, please do not use.
            </summary>
        </member>
    </members>
</doc>
