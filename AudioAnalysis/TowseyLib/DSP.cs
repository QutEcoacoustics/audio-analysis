using System;
using System.Collections.Generic;
using System.Text;

namespace TowseyLib
{

    /// <summary>
    /// digital signal processing methods
    /// </summary>
    public class DSP
    {
        public const double pi = Math.PI;




        /// <summary>
        /// Breaks a long audio signal into frames with given step
        /// </summary>
        /// <param name="data"></param>
        /// <param name="windowSize"></param>
        /// <param name="step"></param>
        /// <returns></returns>
        public static double[,] Frames(double[] data, int windowSize, int step)
        {
            if (step < 1)
                throw new ArgumentException("Frame Step must be at least 1");
            if (step > windowSize)
                throw new ArgumentException("Frame Step must be <=" + windowSize);


            int framecount = (data.Length - windowSize) / step; //this truncates residual samples
            if (framecount < 2) throw new ArgumentException("Sonogram width must be at least 2");

            int offset = 0;
            double[,] frames = new double[framecount, windowSize];

            for (int i = 0; i < framecount; i++) //foreach frame
            {
                for (int j = 0; j < windowSize; j++) //foreach sample
                {
                    frames[i, j] = data[offset + j];
                }
                offset += step;
            } //end matrix
            return frames;
        }





        public static double[] GetSignal(int sampleRate, double duration, int[] freq)
        {
            double ampl = 10000;
            int length = (int)(sampleRate * duration); 
            double[] data = new double[length];
            int count = freq.Length;
            double[] omega = new double[count];

            //for (int f = 0; f < count; f++)
            //{
            //    omega[f] = 2.0 * Math.PI * freq[f] / (double)sampleRate;
            //}


            for (int i = 0; i < length; i++)
            {
                //for (int f = 0; f < count; f++) data[i] += Math.Sin(omega[f] * i);
                for (int f = 0; f < count; f++) data[i] += (ampl * Math.Sin(2.0 * Math.PI * freq[f] * i / (double)sampleRate));
            }
            return data;
        }


        /// <summary>
        /// The source signal for voiced speech, that is, the vibration generated by the glottis or vocal chords,
        /// has a spectral content with more power in low freq than in high. The spectrum has roll off of -6dB/octave.
        /// Many speech analysis methods work better when the souce signal is spectrally flattened.
        /// This is achieved by a high pass filter.
        /// </summary>
        /// <param name="signal"></param>
        /// <param name="coeff"></param>
        /// <returns></returns>
        public static double[] PreEmphasis(double[] signal, double coeff)
        {
            int L = signal.Length;
            double[] newSig = new double[L - 1];
            for (int i = 0; i < L - 1; i++) newSig[i] = signal[i + 1] - (coeff * signal[i]);
            return newSig;
        }


        /// <summary>
        /// Frame energy is the log of the summed energy of the samples.
        /// Need to normalise. Energy normalisation formula taken from Lecture Notes of Prof. Bryan Pellom
        /// Automatic Speech Recognition: From Theory to Practice.
        /// http://www.cis.hut.fi/Opinnot/T-61.184/ September 27th 2004.
        /// </summary>
        /// <param name="frames"></param>
        /// <returns></returns>
        public static double[] SignalEnergy(double[,] frames, double minLogEnergy, double maxLogEnergy)
        {
            //const double minLogEnergy = -5.0; //defined in class header
            //double maxLogEnergy = Math.Log(0.25);//reference energy level = max average amplitude in a signal = 0.5

            int frameCount = frames.GetLength(0);
            int N = frames.GetLength(1);
            double[] energy = new double[frameCount];
            for (int i = 0; i < frameCount; i++) //foreach frame
            {
                double sum = 0.0;
                for (int j = 0; j < N; j++)  //foreach sample in frame
                {
                    sum += (frames[i, j] * frames[i, j]); //sum the energy
                }
                double e = sum / (double)N; //normalise to frame size
                if (e <= 0.0) energy[i] = minLogEnergy;
                //if (Math.Log(e) < minLogEnergy) energy[i] = minLogEnergy;
                else energy[i] = Math.Log(e);
                energy[i] = energy[i] - maxLogEnergy; //normalise to absolute scale
            }

            //normalise to relative energy value i.e. max in the signal
            //double maxEnergy = energy[DataTools.getMaxIndex()];
            //for (int i = 0; i < frameCount; i++) //foreach time step
            //{
            //    //energy[i] = ((energy[i] - maxEnergy) * 0.1) + 1.0; //see method header for reference 
            //}
            return energy;
        }


        /// <summary>
        /// counts the zero crossings in each frame
        /// This info is used for determing the begin and end points for vocalisations.
        /// </summary>
        /// <param name="frames"></param>
        /// <returns></returns>
        public static int[] ZeroCrossings(double[,] frames)
        {
            int frameCount = frames.GetLength(0);
            int N = frames.GetLength(1);
            int[] zc = new int[frameCount];
            for (int i = 0; i < frameCount; i++) //foreach frame
            {
                int count = 0;
                for (int j = 1; j < N; j++)  //foreach sample in frame
                {
                    count += Math.Abs(Math.Sign(frames[i, j]) - Math.Sign(frames[i, j - 1]));
                }
                zc[i] = count / 2;
            }
            return zc;
        }

        /// <summary>
        /// algorithm described in Lamel et al, 1981.
        /// </summary>
        /// <param name="energy"></param>
        /// <param name="minEnergy"></param>
        /// <param name="maxEnergy"></param>
        /// <param name="noiseThreshold"></param>
        /// <returns></returns>
        public static double[] NoiseReduce(double[] energy, double minEnergy, double maxEnergy, double noiseThreshold)
        {
            int binCount = 100;
//            double min;
//            double max;
            int[] histo = DataTools.Histo(energy, binCount);
            //int[] histo = DataTools.Histo(energy, binCount, out binWidth, out min, out max);
            double[] smoothHisto = DataTools.filterMovingAverage(histo, 3);

            //transfer lowest 10dB bins
            double binWidth = (maxEnergy - minEnergy) / (double)binCount; //db/bin
            int low10dB_BinCount = (int)(10 / binWidth);
            if (low10dB_BinCount > binCount) low10dB_BinCount = binCount;
            double[] lowBins = new double[low10dB_BinCount];
            for (int i = 0; i < low10dB_BinCount; i++) lowBins[i] = smoothHisto[i];

            // find peak of lowBins histogram
            int peakID = DataTools.GetMaxIndex(lowBins);
            double Q = (peakID * binWidth) + (0.5 * binWidth);

            // subtract noise energy
            int L = energy.Length;
            double[] en = new double[L];
            for (int i = 0; i < L; i++) en[i] = energy[i] - Q;

            return en;
        }

        /// <summary>
        /// converts passed arguments into step decay and step radians ie radians per sample or OMEGA
        /// </summary>
        /// <param name="signal"></param>
        /// <param name="sf">sampling frequency</param>
        /// <param name="tHalf">half life in seconds</param>
        /// <param name="period">of the cycle of interest</param>
        /// <param name="filterLength">length of filter in seconds</param>
        /// <returns></returns>
        public static double[] Filter_DecayingSinusoid(double[] signal, double sf, double tHalf, double period, double filterDuration)
        {
            double t = 1/sf; //inverse of sampling frequency (in seconds)

            double samplesPerTHalf = tHalf*sf;
            double stepDecay = 0.5 / samplesPerTHalf; 
            double samplesPerPeriod = period*sf;
            double stepRadians = 2 * pi / samplesPerPeriod;
            int filterLength = (int)(filterDuration * sf); 
            double[] newSig = Filter_DecayingSinusoid(signal, stepDecay, stepRadians, filterLength);
            return newSig;

        }


        public static double[] Filter_DecayingSinusoid(double[] signal, double stepDecay, double stepRadians, int filterLength)
        {   
            double B = stepDecay; // beta = decay per signal sample
            double W = stepRadians; // OMEGA = radians per signal sample
            
            double[] coeff = new double[filterLength];
            int signalLength = signal.Length;
            double[] newSig = new double[signalLength];

            // set up the coefficients
            for(int n=0; n<filterLength; n++)
            {
                double angle = W*n;
                double decay = B*n;
                coeff[filterLength-n-1] = Math.Cos(angle)*Math.Exp(-decay);
            }


            // transfer initial partially filtered values
            for (int i = 0; i < filterLength; i++)
            {
                double sum = 0.0;
                for (int j = 0; j < filterLength; j++)
                {
                    if ((i - j) < 0) break;
                    sum += (coeff[filterLength - j - 1] * signal[i - j]);
                }
                newSig[i] = sum;
            }
            // transfer filtered values
            for(int i=filterLength; i<signalLength; i++)
            {   
                double sum = 0.0;
                for(int j=0; j<filterLength; j++) sum += (coeff[filterLength-j-1] * signal[i-j]);
                newSig[i] = sum;
            }
            //System.Console.WriteLine("FilterGain="+DSP.GetGain(coeff));
            return newSig;
        } //Filter_DecayingSinusoid()

        public static double[] Filter(double[] signal, double[] filterCoeff)
        {
            int signalLength = signal.Length;
            double[] newSig = new double[signalLength];

            int filterLength = filterCoeff.Length;
            // transfer initial partially filtered values
            for (int i = 0; i < filterLength; i++)
            {
                double sum = 0.0;
                for (int j = 0; j < filterLength; j++)
                {
                    if ((i - j) < 0) break;
                    sum += (filterCoeff[filterLength - j - 1] * signal[i - j]);
                }
                newSig[i] = sum;
            }
            // transfer filtered values
            for (int i = filterLength; i < signalLength; i++)
            {
                double sum = 0.0;
                for (int j = 0; j < filterLength; j++) sum += (filterCoeff[filterLength - j - 1] * signal[i - j]);
                newSig[i] = sum;
            }
            return newSig;
        } //Filter()

        public static double GetGain(double[] filterCoeff)
        {
            int filterLength = filterCoeff.Length;
            //set up the impulse signal
            double[] impulse = new double[3 * filterLength];
            impulse[filterLength] = 1.0;
            double[] newSig = Filter(impulse, filterCoeff);
            double gain = 0.0;
            for (int j = 0; j < impulse.Length; j++) gain += newSig[j];
            return gain;
        }

        public static void DisplaySignal(double[] sig)
        {
                double[] newSig = DataTools.normalise(sig);

                foreach (double value in newSig)
                {
                    int count = (int)(value * 50);
                    for (int i = 0; i < count; i++) Console.Write("=");
                    Console.WriteLine("=");
                }
        }

        public static void DisplaySignal(double[] sig, bool showIndex)
        {
            double[] newSig = DataTools.normalise(sig);

            for (int n = 0; n < sig.Length; n++)
            {
                if (showIndex) Console.Write(n.ToString("D3") + "|");
                int count = (int)(newSig[n] * 50);
                for (int i = 0; i < count; i++)
                {
                    Console.Write("=");
                }
                Console.WriteLine("=");
            }
        }




        static void Main()
        {
            Console.WriteLine("TESTING METHODS IN CLASS DataTools");



            //COPY THIS TEST TEMPLATE
            if (false) //test Method(parameters)
            {   
                System.Console.WriteLine("\nTest of METHOD)");
            }//end test Method(string fName)



            if (true) //test Method(parameters)
           {
                System.Console.WriteLine("\nTest of Filter_DecayingSinusoid()");
                double sf = 100;
                double tHalf = 0.2;//seconds
                double period = 0.2; //seconds
                double filterDuration = 1.0; //seconds
                int signalLength= 100;
                
                //set up the impulse signal
                double[] signal = new double[signalLength];
                signal[10] = 1.0;
                double[] newSig = Filter_DecayingSinusoid(signal, sf, tHalf, period, filterDuration);
                DisplaySignal(newSig, true);
            }//end test Method(string fName)



            if (false) //test Filter_DecayingSinusoid()
            {
                System.Console.WriteLine("\nTest of Filter_DecayingSinusoid()");
                int signalLength= 100;
                //set up the impulse signal
                double[] signal = new double[signalLength];
                signal[10] = 1.0;

                //filter constatns
                double stepDecay= 0.05 ;
                double stepRadians = 0.4;
                int filterLength = 50;//number of time delays or coefficients in the filter
                double[] newSig = Filter_DecayingSinusoid(signal, stepDecay, stepRadians, filterLength);
                DisplaySignal(newSig, true);
            }

            Console.WriteLine("FINISHED!!");
            Console.ReadLine();
        }//end Main()

    }//end class DSP
}
