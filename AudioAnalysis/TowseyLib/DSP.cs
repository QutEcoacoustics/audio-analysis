using System;
using System.Collections.Generic;
using System.Text;

namespace TowseyLib
{
    /// <summary>
    /// digital signal processing methods
    /// </summary>
    public static class DSP
    {
        public const double pi = Math.PI;



        /// <summary>
        /// Breaks a long audio signal into frames with given step
        /// </summary>
        public static double[,] Frames(double[] data, int windowSize, double windowOverlap)
        {
            int step = (int)(windowSize * (1 - windowOverlap));

            if (step < 1)
                throw new ArgumentException("Frame Step must be at least 1");
            if (step > windowSize)
                throw new ArgumentException("Frame Step must be <=" + windowSize);

            int framecount = (data.Length - windowSize) / step; //this truncates residual samples
            if (framecount < 2) throw new ArgumentException("Sonogram width must be at least 2");

            int offset = 0;
            double[,] frames = new double[framecount, windowSize];

            for (int i = 0; i < framecount; i++) //foreach frame
            {
                for (int j = 0; j < windowSize; j++) //foreach sample
                    frames[i, j] = data[offset + j];
                offset += step;
            } //end matrix
            return frames;
        }

        public static double[] GetSignal(int sampleRate, double duration, int[] freq)
        {
            double ampl = 10000;
            int length = (int)(sampleRate * duration); 
            double[] data = new double[length];
            int count = freq.Length;
            double[] omega = new double[count];

            //for (int f = 0; f < count; f++)
            //{
            //    omega[f] = 2.0 * Math.PI * freq[f] / (double)sampleRate;
            //}


            for (int i = 0; i < length; i++)
            {
                //for (int f = 0; f < count; f++) data[i] += Math.Sin(omega[f] * i);
                for (int f = 0; f < count; f++) data[i] += (ampl * Math.Sin(2.0 * Math.PI * freq[f] * i / (double)sampleRate));
            }
            return data;
        }


        /// <summary>
        /// The source signal for voiced speech, that is, the vibration generated by the glottis or vocal chords,
        /// has a spectral content with more power in low freq than in high. The spectrum has roll off of -6dB/octave.
        /// Many speech analysis methods work better when the souce signal is spectrally flattened.
        /// This is achieved by a high pass filter.
        /// </summary>
        /// <param name="signal"></param>
        /// <param name="coeff"></param>
        /// <returns></returns>
        public static double[] PreEmphasis(double[] signal, double coeff)
        {
            int L = signal.Length;
            double[] newSig = new double[L - 1];
            for (int i = 0; i < L - 1; i++) newSig[i] = signal[i + 1] - (coeff * signal[i]);
            return newSig;
        }

        /// <summary>
        /// returns the min and max values in each frame. Signal values range from -1 to +1.
        /// </summary>
        /// <param name="frames"></param>
        /// <param name="minAmp"></param>
        /// <param name="maxAmp"></param>
        public static void SignalEnvelope(double[,] frames, out double[] minAmp, out double[] maxAmp)
        {
            int frameCount = frames.GetLength(0);
            int N  = frames.GetLength(1);
            minAmp = new double[frameCount];
            maxAmp = new double[frameCount];
            for (int i = 0; i < frameCount; i++) //foreach frame
            {
                double min =  Double.MaxValue;
                double max = -Double.MaxValue;
                for (int j = 0; j < N; j++)  //foreach sample in frame
                {
                    if (min > frames[i, j]) min = frames[i, j];
                    else 
                    if (max < frames[i, j]) max = frames[i, j];
                }
                minAmp[i] = min;
                maxAmp[i] = max;
            }
        }




        /// <summary>
        /// counts the zero crossings in each frame
        /// This info is used for determing the begin and end points for vocalisations.
        /// </summary>
        /// <param name="frames"></param>
        /// <returns></returns>
        public static int[] ZeroCrossings(double[,] frames)
        {
            int frameCount = frames.GetLength(0);
            int N = frames.GetLength(1);
            int[] zc = new int[frameCount];
            for (int i = 0; i < frameCount; i++) //foreach frame
            {
                int count = 0;
                for (int j = 1; j < N; j++)  //foreach sample in frame
                {
                    count += Math.Abs(Math.Sign(frames[i, j]) - Math.Sign(frames[i, j - 1]));
                }
                zc[i] = count / 2;
            }
            return zc;
        }

        /// <summary>
        /// converts passed arguments into step decay and step radians ie radians per sample or OMEGA
        /// </summary>
        /// <param name="signal"></param>
        /// <param name="sf">sampling frequency</param>
        /// <param name="tHalf">half life in seconds</param>
        /// <param name="period">of the cycle of interest</param>
        /// <param name="filterLength">length of filter in seconds</param>
        /// <returns></returns>
        public static double[] Filter_DecayingSinusoid(double[] signal, double sf, double tHalf, double period, double filterDuration)
        {
            double t = 1/sf; //inverse of sampling frequency (in seconds)

            double samplesPerTHalf = tHalf*sf;
            double stepDecay = 0.5 / samplesPerTHalf; 
            double samplesPerPeriod = period*sf;
            double stepRadians = 2 * pi / samplesPerPeriod;
            int filterLength = (int)(filterDuration * sf); 
            double[] newSig = Filter_DecayingSinusoid(signal, stepDecay, stepRadians, filterLength);
            return newSig;

        }


        public static double[] Filter_DecayingSinusoid(double[] signal, double stepDecay, double stepRadians, int filterLength)
        {   
            double B = stepDecay; // beta = decay per signal sample
            double W = stepRadians; // OMEGA = radians per signal sample
            
            double[] coeff = new double[filterLength];
            int signalLength = signal.Length;
            double[] newSig = new double[signalLength];

            // set up the coefficients
            for(int n=0; n<filterLength; n++)
            {
                double angle = W*n;
                double decay = B*n;
                coeff[filterLength-n-1] = Math.Cos(angle)*Math.Exp(-decay);
            }


            // transfer initial partially filtered values
            for (int i = 0; i < filterLength; i++)
            {
                double sum = 0.0;
                for (int j = 0; j < filterLength; j++)
                {
                    if ((i - j) < 0) break;
                    sum += (coeff[filterLength - j - 1] * signal[i - j]);
                }
                newSig[i] = sum;
            }
            // transfer filtered values
            for(int i=filterLength; i<signalLength; i++)
            {   
                double sum = 0.0;
                for(int j=0; j<filterLength; j++) sum += (coeff[filterLength-j-1] * signal[i-j]);
                newSig[i] = sum;
            }
            //System.Console.WriteLine("FilterGain="+DSP.GetGain(coeff));
            return newSig;
        } //Filter_DecayingSinusoid()

        public static double[] Filter(double[] signal, double[] filterCoeff)
        {
            int signalLength = signal.Length;
            double[] newSig = new double[signalLength];

            int filterLength = filterCoeff.Length;
            // transfer initial partially filtered values
            for (int i = 0; i < filterLength; i++)
            {
                double sum = 0.0;
                for (int j = 0; j < filterLength; j++)
                {
                    if ((i - j) < 0) break;
                    sum += (filterCoeff[filterLength - j - 1] * signal[i - j]);
                }
                newSig[i] = sum;
            }
            // transfer filtered values
            for (int i = filterLength; i < signalLength; i++)
            {
                double sum = 0.0;
                for (int j = 0; j < filterLength; j++) sum += (filterCoeff[filterLength - j - 1] * signal[i - j]);
                newSig[i] = sum;
            }
            return newSig;
        } //Filter()

        public static double GetGain(double[] filterCoeff)
        {
            int filterLength = filterCoeff.Length;
            //set up the impulse signal
            double[] impulse = new double[3 * filterLength];
            impulse[filterLength] = 1.0;
            double[] newSig = Filter(impulse, filterCoeff);
            double gain = 0.0;
            for (int j = 0; j < impulse.Length; j++) gain += newSig[j];
            return gain;
        }

        public static void DisplaySignal(double[] sig)
        {
                double[] newSig = DataTools.normalise(sig);

                foreach (double value in newSig)
                {
                    int count = (int)(value * 50);
                    for (int i = 0; i < count; i++) Console.Write("=");
                    Console.WriteLine("=");
                }
        }

        public static void DisplaySignal(double[] sig, bool showIndex)
        {
            double[] newSig = DataTools.normalise(sig);

            for (int n = 0; n < sig.Length; n++)
            {
                if (showIndex) Console.Write(n.ToString("D3") + "|");
                int count = (int)(newSig[n] * 50);
                for (int i = 0; i < count; i++)
                {
                    Console.Write("=");
                }
                Console.WriteLine("=");
            }
        }




        static void Main()
        {
            Console.WriteLine("TESTING METHODS IN CLASS DataTools");



            //COPY THIS TEST TEMPLATE
            bool doit1 = false;
            if (doit1) //test Method(parameters)
            {   
                System.Console.WriteLine("\nTest of METHOD)");
            }//end test Method(string fName)



            bool doit2 = true;
            if (doit2) //test Method(parameters)
            {
                System.Console.WriteLine("\nTest of Filter_DecayingSinusoid()");
                double sf = 100;
                double tHalf = 0.2;//seconds
                double period = 0.2; //seconds
                double filterDuration = 1.0; //seconds
                int signalLength= 100;
                
                //set up the impulse signal
                double[] signal = new double[signalLength];
                signal[10] = 1.0;
                double[] newSig = Filter_DecayingSinusoid(signal, sf, tHalf, period, filterDuration);
                DisplaySignal(newSig, true);
            }//end test Method(string fName)



            bool doit3 = false;
            if (doit3) //test Filter_DecayingSinusoid()
            {
                System.Console.WriteLine("\nTest of Filter_DecayingSinusoid()");
                int signalLength= 100;
                //set up the impulse signal
                double[] signal = new double[signalLength];
                signal[10] = 1.0;

                //filter constatns
                double stepDecay= 0.05 ;
                double stepRadians = 0.4;
                int filterLength = 50;//number of time delays or coefficients in the filter
                double[] newSig = Filter_DecayingSinusoid(signal, stepDecay, stepRadians, filterLength);
                DisplaySignal(newSig, true);
            }

            Console.WriteLine("FINISHED!!");
            Console.ReadLine();
        }//end Main()

    }//end class DSP
}
