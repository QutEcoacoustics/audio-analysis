using System;
using System.Collections.Generic;
using System.Text;
using TowseyLibrary;

namespace AudioAnalysisTools.DSP
{
    /// <summary>
    /// digital signal processing FILTERS methods
    /// </summary>
    public static class DSP_Filters
    {
        public const double pi = Math.PI;


        /// <summary>
        /// returns a digital signal having sample rate, duration and harmonic content passed by user.
        /// Harmonics array should contain Herz values of harmonics. i.e. int[] harmonics = { 500, 1000, 2000, 4000 };
        /// Phase is not taken into account.
        /// </summary>
        /// <param name="sampleRate">sr of output signal</param>
        /// <param name="duration">signal duration in seconds</param>
        /// <param name="freq">frequency in Herz</param>
        /// <returns></returns>
        public static double[] GetSignal(int sampleRate, double duration, int[] freq)
        {
            double ampl = 10000;
            int length = (int)(sampleRate * duration);
            double[] data = new double[length];
            int count = freq.Length;
            double[] omega = new double[count];

            //for (int f = 0; f < count; f++)
            //{
            //    omega[f] = 2.0 * Math.PI * freq[f] / (double)sampleRate;
            //}

            for (int i = 0; i < length; i++)
            {
                //for (int f = 0; f < count; f++) data[i] += Math.Sin(omega[f] * i);
                for (int f = 0; f < count; f++) data[i] += (ampl * Math.Sin(2.0 * Math.PI * freq[f] * i / (double)sampleRate));
            }
            return data;
        }


        /// <summary>
        /// The source signal for voiced speech, that is, the vibration generated by the glottis or vocal chords,
        /// has a spectral content with more power in low freq than in high. The spectrum has roll off of -6dB/octave.
        /// Many speech analysis methods work better when the souce signal is spectrally flattened.
        /// This is achieved by a high pass filter.
        /// </summary>
        /// <param name="signal"></param>
        /// <param name="coeff"></param>
        /// <returns></returns>
        public static double[] PreEmphasis(double[] signal, double coeff)
        {
            int L = signal.Length;
            double[] newSig = new double[L - 1];
            for (int i = 0; i < L - 1; i++) newSig[i] = signal[i + 1] - (coeff * signal[i]);
            return newSig;
        }


        /// <summary>
        /// converts passed arguments into step decay and step radians ie radians per sample or OMEGA
        /// </summary>
        /// <param name="signal"></param>
        /// <param name="sf">sampling frequency</param>
        /// <param name="tHalf">half life in seconds</param>
        /// <param name="period">of the cycle of interest</param>
        /// <param name="filterLength">length of filter in seconds</param>
        /// <returns></returns>
        public static double[] Filter_DecayingSinusoid(double[] signal, double sf, double tHalf, double period, double filterDuration)
        {
            double t = 1/sf; //inverse of sampling frequency (in seconds)

            double samplesPerTHalf = tHalf*sf;
            double stepDecay = 0.5 / samplesPerTHalf; 
            double samplesPerPeriod = period*sf;
            double stepRadians = 2 * pi / samplesPerPeriod;
            int filterLength = (int)(filterDuration * sf); 
            double[] newSig = Filter_DecayingSinusoid(signal, stepDecay, stepRadians, filterLength);
            return newSig;
        }


        public static double[] Filter_DecayingSinusoid(double[] signal, double stepDecay, double stepRadians, int filterLength)
        {   
            double B = stepDecay; // beta = decay per signal sample
            double W = stepRadians; // OMEGA = radians per signal sample
            
            double[] coeff = new double[filterLength];
            int signalLength = signal.Length;
            double[] newSig = new double[signalLength];

            // set up the coefficients
            for(int n=0; n<filterLength; n++)
            {
                double angle = W*n;
                double decay = B*n;
                coeff[filterLength-n-1] = Math.Cos(angle)*Math.Exp(-decay);
            }


            // transfer initial partially filtered values
            for (int i = 0; i < filterLength; i++)
            {
                double sum = 0.0;
                for (int j = 0; j < filterLength; j++)
                {
                    if ((i - j) < 0) break;
                    sum += (coeff[filterLength - j - 1] * signal[i - j]);
                }
                newSig[i] = sum;
            }
            // transfer filtered values
            for(int i=filterLength; i<signalLength; i++)
            {   
                double sum = 0.0;
                for(int j=0; j<filterLength; j++) sum += (coeff[filterLength-j-1] * signal[i-j]);
                newSig[i] = sum;
            }
            //System.LoggedConsole.WriteLine("FilterGain="+DSP.GetGain(coeff));
            return newSig;
        } //Filter_DecayingSinusoid()


        /// <summary>
        /// A "finite impulse response" (FIR) filter uses only the input signals, 
        /// while an "infinite impulse response" filter (IIR) uses 
        /// both the input signal and previous samples of the output signal.
        /// 
        /// FIR filters are always stable, while IIR filters may be unstable.
        /// This filter is linear, causal and time-invariant.
        /// </summary>
        /// <param name="signal">input signal</param>
        /// <param name="filterCoeff">filter coefficients</param>
        /// <returns>the filtered signal</returns>
        public static double[] FIR_Filter(double[] signal, double[] filterCoeff)
        {
            int signalLength = signal.Length;
            double[] newSig = new double[signalLength];

            int filterLength = filterCoeff.Length;
            // transfer initial partially filtered values
            for (int i = 0; i < filterLength; i++)
            {
                double sum = 0.0;
                for (int j = 0; j < filterLength; j++)
                {
                    if ((i - j) < 0) break;
                    sum += (filterCoeff[filterLength - j - 1] * signal[i - j]);
                }
                newSig[i] = sum;
            }
            // transfer filtered values
            for (int i = filterLength; i < signalLength; i++)
            {
                double sum = 0.0;
                for (int j = 0; j < filterLength; j++) sum += (filterCoeff[filterLength - j - 1] * signal[i - j]);
                newSig[i] = sum;
            }
            return newSig;
        } //FIR_Filter()

        public static double GetGain(double[] filterCoeff)
        {
            int filterLength = filterCoeff.Length;
            //set up the impulse signal
            double[] impulse = new double[3 * filterLength];
            impulse[filterLength] = 1.0;
            double[] newSig = FIR_Filter(impulse, filterCoeff);
            double gain = 0.0;
            for (int j = 0; j < impulse.Length; j++) gain += newSig[j];
            return gain;
        }

        public static void DisplaySignal(double[] sig)
        {
            double[] newSig = DataTools.normalise(sig);

            foreach (double value in newSig)
            {
                int count = (int)(value * 50);
                for (int i = 0; i < count; i++) LoggedConsole.Write("=");
                LoggedConsole.WriteLine("=");
            }
        }

        public static void DisplaySignal(double[] sig, bool showIndex)
        {
            double[] newSig = DataTools.normalise(sig);

            for (int n = 0; n < sig.Length; n++)
            {
                if (showIndex) LoggedConsole.Write(n.ToString("D3") + "|");
                int count = (int)(newSig[n] * 50);
                for (int i = 0; i < count; i++)
                {
                    LoggedConsole.Write("=");
                }
                LoggedConsole.WriteLine("=");
            }
        }




        static void Main()
        {
            LoggedConsole.WriteLine("TESTING METHODS IN CLASS DSP_Filters");



            //COPY THIS TEST TEMPLATE
            bool doit1 = false;
            if (doit1) //test Method(parameters)
            {   
                System.LoggedConsole.WriteLine("\nTest of METHOD)");
            }//end test Method(string fName)



            bool doit2 = true;
            if (doit2) //test Method(parameters)
            {
                System.LoggedConsole.WriteLine("\nTest of Filter_DecayingSinusoid()");
                double sf = 100;
                double tHalf = 0.2;//seconds
                double period = 0.2; //seconds
                double filterDuration = 1.0; //seconds
                int signalLength= 100;
                
                //set up the impulse signal
                double[] signal = new double[signalLength];
                signal[10] = 1.0;
                double[] newSig = Filter_DecayingSinusoid(signal, sf, tHalf, period, filterDuration);
                DisplaySignal(newSig, true);
            }//end test Method(string fName)



            bool doit3 = false;
            if (doit3) //test Filter_DecayingSinusoid()
            {
                System.LoggedConsole.WriteLine("\nTest of Filter_DecayingSinusoid()");
                int signalLength= 100;
                //set up the impulse signal
                double[] signal = new double[signalLength];
                signal[10] = 1.0;

                //filter constatns
                double stepDecay= 0.05 ;
                double stepRadians = 0.4;
                int filterLength = 50;//number of time delays or coefficients in the filter
                double[] newSig = Filter_DecayingSinusoid(signal, stepDecay, stepRadians, filterLength);
                DisplaySignal(newSig, true);
            }

            LoggedConsole.WriteLine("FINISHED!!");
            Console.ReadLine();
        }//end Main()

    }//end class DSP
}
