Confirm <- function (msg, default = NULL) {
    options <- c('Yes', 'No')
    if (!is.null(default)) {    
        if (default %in% c('y', 'Y', 'yes', 1, TRUE)) {
            default <- 1
        } else {
            default <- 2
        }   
        options[default] <- paste(options[default], "(default)")
    }
    # output yes / no
    cat(paste0(1:length(options), ") ", options, collapse = '\n'))    
    choice <- GetValidatedInt(msg, max = length(options), default = default, parse.range = FALSE, equivalents = list('y' = 1, 'n' = 2))
    if (choice == 1) {
        return(TRUE)
    } else {
        return(FALSE)
    }  
}


GetUserChoice <- function (choices, choosing.what = "one of the following", default = 1, allow.range = FALSE, config.setting = NULL, optional = FALSE) {
    # given a list of choices, returns the index of the choice selected by the user
    # 
    # Args
    #   choices: vector of strings
    #   choosing.what: string; used for presenting the instructions to the user
    #   default: int; if the user just hits enter, this will be chosen
    #   allow.rangs: Boolean; if TRUE, the user can enter something like 2-4 which will return c(2,3,4)
    #   config.setting: string or NULL. If set, will look for a value set in config, instead of asking for user input
    #   optional: boolean; if TRUE, user can select 0 to return false (i.e. no choice)
    
    # to avoid tedious repeated selection of the same choice, 
    # config settings can be set to do the choice automatically
    choice <- GetConfigSettingForInput(choices, config.setting)
    if (choice != FALSE) {
        return(choice)
    }
    
    
    #todo recursive validation like http://www.rexamples.com/4/Reading%20user%20input
    cat(paste0("choose ", choosing.what, ":\n"))
    if (optional) {
        cat(paste0(0:length(choices), ") ", c("none", choices), collapse = '\n'))
        min <- 0
    } else {
        cat(paste0(1:length(choices), ") ", choices, collapse = '\n'))
        min <- 1
    }

    if (default %in% 1:length(choices)) {
        cat(paste('\ndefault: ', default))
    } else {
        default = NA
    }
    msg <- paste0("enter int 1 to ",length(choices),": ")
    choice <- GetValidatedInt(msg, min = min, max = length(choices), default = default, parse.range = allow.range)  
    return(choice)
}

GetMultiUserchoice <- function (options, choosing.what = 'one of the following', default = 1, all = FALSE, config.setting = NULL) {
    # allows the user to select 1 or more of the choices, returning a vector 
    # of the choice numbers
    #
    # Args
    #   options: string vector; list of choices
    #   choosing what: string; instrucitons for user
    #   default: int or string "all"; which options should be selected if the just hits clicks 'enter'
    #   all: boolean: should there be an extra option at the end to choose all the options in the list?
    #   config.setting: string or NULL. If set, will look for a value set in config, instead of asking for user input
    
    choice <- GetConfigSettingForInput(options, config.setting)
    if (choice != FALSE) {
        return(choice)
    }
    
    if (length(options) == 1 && (default == 1 || default == 'all')) {
        # if there was only 1 option and the default is 1 or 'all',
        # then just return that option without getting user input
        return(c(1))
    }
    
    
    if (default == 'all') {
        all <- TRUE
    }
    
    if (all) {
        options <- c(options, 'all')
        all.choice <- length(options)
        if (default == 'all') {
            default <- all.choice
        }
    } else {
        all.choice <- -99  # can't choose all
    }
    
    options <- c(options, 'exit')
    exit.choice <- length(options)
    last.choice <- -1;
    chosen <- c()
    while(TRUE) {
        if (max(last.choice) > 0) {
            # if something has been chosen, change the default to exit
            default = exit.choice
        }
        last.choice <- GetUserChoice(options, choosing.what, default = default, allow.range = TRUE)
        should.exit <- exit.choice %in% last.choice
        should.use.all <- all.choice %in% last.choice
        if (should.use.all) {
            chosen <- 1:length(options)
            break()
        }
        if (should.exit) {
            break()
        } else  {
            chosen <- union(chosen, last.choice)    
        }
    }
    # setdiff also returns unique
    chosen <- setdiff(chosen, c(exit.choice, all.choice))
    return(chosen)
}

GetConfigSettingForInput <- function (choices, config.setting.name = NULL) {
    # Sometimes, the user is required to choose from a list of choices, 
    # however, the choice can also be set in the config, saving the hassle of entering the same
    # choice over and over. This function looks for the config setting for the choice and 
    # returns its number. If the config.setting.name is NULL or the value of the config setting 
    # is NULL or is not in the list of choices, will return FALSE
    # 
    # Args
    #   choices: string vector; the list of possible choices
    #   config.setting.name; string; the name of the config setting for user input which holds which of the choices to select. 
    
    if (!is.null(config.setting.name) && !is.null(g.user.input[[config.setting.name]])) {
        val <- g.user.input[[config.setting.name]]
        val.index <- match(val, choices)
        if (!is.na(val.index[1])) {
            return(val.index)
        } else {
            Report('user choice set in config is not in the list of choices. Getting user choice. ')
        }
    }
    return(FALSE);
}



GetValidatedInt <- function (msg, max = NA, min = 1, default = NULL, num.attempts = 0, parse.range = FALSE, equivalents = list(), quit = "Q") { 
    # gets user user input, which must be an integer must be between max and min to validate.
    # msg: string; the message to display. eg, choose a number between 1 and 10, or choose from the following options
    # max: int; optional. the highest allowed integer
    # min: int; optional. the lowest allowed integer
    # default: int; optional. The integer which will be returned if nothing is inputted (i.e. user hits return)
    # num.attempts: int; The number of attempts attempted so far. The method recurses on itself to give the user another chance if
    #                    the input doesn't validate. This is only used by the recusive function call.
    # parse.range: boolean; if TRUE, validates a range of int in the form "from-to", eg 2-4, and returns a vector containing that range
    # equivalents: list; Allows the user to enter any of the values in the list which will be interpreted as the corresponding name in the list
    # quit: string; If the input equals this, the program will quit. Allows the user to quit during a request for input
    
    
    max.attempts <- 8
    choice <- readline(paste(msg, " : "))
    
    if (choice == quit) {
        stop('quitting')
    }
    
    if (!is.null(equivalents[[choice]])) {
        choice <- equivalents[[choice]]
    } 
    
    if (choice == '' && !is.null(default)) {
        choice <- as.integer(default)
    } else if (grepl("^[0-9]+$",choice)) {
        choice <- as.integer(choice)
    } else if (parse.range && grepl("^[0-9]+[ ]*[:-][ ]*[0-9]+$",choice)) {
        # split by hyphen and parse range
        values <- regmatches(choice, gregexpr("[0-9]+", choice))
        choice <- as.integer(values[[1]][1]):as.integer(values[[1]][2])
    }
    
    if (num.attempts > max.attempts) {
        stop("you kept entering an invalid choice, idiot")
    } else if (class(choice) != 'integer' || (!is.na(max) && max(choice) > max) || (!is.na(min) && min(choice) < min)) {
        if (num.attempts == 0) {
            msg <- paste("Invalid choice.", msg)
        }
        GetValidatedInt(msg, max = max, min = min, default = default, num.attempts = num.attempts + 1, parse.range = parse.range, equivalents = equivalents)
    } else {
        return(choice)
    }
}

GetValidatedFloat <- function (msg = 'Enter a number', max = NA, min = 0, default = NA, num.attempts = 0, quit = "Q") {
    max.attempts <- 8 
    val <- readline(paste(msg, " : "))
    if (val == quit) {
        stop('quitting')
    }
    if (val == '' && !is.na(default)) {
        val <- as.numeric(default)
    } else if (grepl("^-?[0-9]+.?[0-9]*$",val)) {
        val <- as.numeric(val)
    }
    if (num.attempts > max.attempts) {
        stop("you kept entering an invalid choice, idiot")
    } else if (class(val) != 'numeric' || (!is.na(max) && max(val) > max) || (!is.na(min) && min(val) < min)) {
        if (num.attempts == 0) {
            msg <- paste("Invalid choice.", msg)
        }
        GetValidatedFloat(msg, max = max, min = min, default = default, num.attempts = num.attempts + 1)  
    } else {
        return(val)
    }
}



ReadInt <- function (msg = "Enter an integer", min = 1, max = NA, default = NA) { 
    extra <- c();
    if (!is.na(min)) {
        extra <- c(extra, paste('min', min))
    }
    if (!is.na(max)) {
        extra <- c(extra, paste('max', max))
    }
    
    if (!is.na(default)) {
        extra <- c(extra, paste('default', default))
    }
    
    if (length(extra) > 0) {
        msg <- paste0(msg, " (", paste(extra, collapse = ", "), ")")
    }
    val <- GetValidatedInt(min = min, max = max, default = default, msg = msg)
    return(val)    
}





Report <- function (level, ..., nl.before = FALSE, nl.after = TRUE) {
    # prints output to the screen if the level is above the 
    # global output level. 
    #
    # Args:
    #   level: int; how important is this? 1 = most important
    #   ... : strings;  concatenated to form the message
    #   nl: boolean; whether to start at a new line
    if (level <= g.report.level) {
        if (nl.before) {
            cat("\n")
        }
        cat(paste(c(paste(as.vector(list(...)),  collapse = " ")), collapse = ""))
        if (nl.after) {
            cat("\n")
        }
    }
}

ReportAnimated <- function (level, ..., nl.before = FALSE, nl.after = TRUE, duration = NULL, after = 4) {
    # prints to screen, but does it one character at a time
    if (level <= g.report.level) {
        if (nl.before) {
            cat("\n")
        }
        str <- paste(c(paste(as.vector(list(...)),  collapse = " ")), collapse = "")
        str <- strsplit(str, '')[[1]]
        str <- c(str, rep(".", round(after*length(str))))
        if (is.null(duration)) {
            sleep.for <- 0.1
        } else {
            sleep.for <- duration / length(str)  
        }

        for (char in str) {
            cat(char)
            Sys.sleep(sleep.for)
        }
        
        if (nl.after) {
            cat("\n")
        }
    }
}

Dot <- function(level = 5) {
    #outputs a dot, used for feedback during long loops
    if (level <= g.report.level) {
        cat(".")
    }
}

Timer <- function(prev = NULL, what = 'processing', num = NULL, per = "each") {
    # used for reporting on the execution time of parts of the code
    if(is.null(prev)) {
        return(proc.time())
    } else {
        t <- (proc.time() - prev)[3]
        Report(3, 'finished', what, 'in', round(t, 2), ' sec')
        if (is.numeric(num) && num > 0) {
            time.per.each <- round(t / num, 3)
            Report(3, time.per.each, "per", per)
        } 
    }
}

