# utility functions which are not specific to any particular step 
# (or which might be used by other steps in the future)



# TODO: check fix this so that it makes sense given that the bottom 
#      frequency is the top row
SliceStft <- function (bounds, spectro, get.bounds = FALSE) {
    # Extracts the stft values within a given bounding box from 
    # a longer stft matrix
    #
    # Args:
    #   bounds: vector; contains 4 numeric values:
    #           start.time, duration, bottom.f, top.f
    #           - start.time: number of seconds from the start of the 
    #                         stft matrix to begin the slice
    #           - duration: number of seconds to include in the slice
    #           - bottom.f: lower frequency bound in Hz
    #           - top.f: upper frequency bount in Hz
    #   spectro: spectrogram; what to take the slice from
    #   get.bounds: boolean; whether to return a matrix of values (false) 
    #                        or just the row and column numbers
    #
    # Returns:
    #   Mixed: either matrix of values or list of 
    #          bounds [left.col, right.col, top.row, bottom.row]

    
    start.time <- bounds[1]
    duration <- bounds[2]
    bottom.f <- bounds[3]
    top.f <- bounds[4]
    
    
    # set bottom and top frequncy to FALSE to use the whole frequency range
    if (bottom.f == FALSE) {
        bottom.f <- 0
    }
    if (top.f == FALSE) {
        top.f <- spectro$frequency.range
    }
    
    
    
    left.col <- TimeToColNum(start.time, spectro$frames.per.sec, ncol(spectro$vals))
    right.col <- TimeToColNum(start.time + duration, spectro$frames.per.sec, ncol(spectro$vals))
    top.row <- FrequencyToRowNum(top.f, spectro$hz.per.bin)
    bottom.row <- FrequencyToRowNum(bottom.f, spectro$hz.per.bin)
    if (get.bounds) {
        return(list(left.col = left.col, 
                    right.col = right.col, 
                    top.row = top.row, 
                    bottom.row = bottom.row))
    } else {
        # slice the part out and return the sub-matrix
        sub <- spectro$vals[bottom.row:top.row, left.col:right.col]
        # makes sure that it is a matrix even if there is only 1 row or column
        sub <- matrix(sub, ncol = (right.col - left.col + 1))

        return(sub)	
    }
}

VectorFluctuation <- function (v, relative = TRUE) {
    # Returns the sum of the difference between consecutive values in a vector
    #
    # Args
    #    v: vector
    #    relative: boolean; whether to return the total or the mean. 
    #
    # Returns: 
    #   number;
    #
    # Details:
    #   eg. [1, 5, 2, 9] would return 14 (4 + 3 + 7)
    
    v1 <- v[1:(length(v) - 1)]
    v2 <- v[2:(length(v))]
    diff <- abs(v1 - v2)
    fluctuation <- sum(diff)
    
    if (relative) {
        fluctuation <- mean(diff) 
    } else {
        fluctuation <- sum(diff)
    }
    
    return(fluctuation)  
}

# this whole function is crap
FindCenter <- function (v) {
    # Finds the index of a vector so that the values on each side 
    # add up to the same. Returns a float, which shows the proportion of 
    # the central value that belongs on each side
    #
    # Args:
    #   v: vector of numbers
    # 
    # Returns:
    #   float;
    #
    # Details:
    #   examples:
    #   v = c(1,1,1,1,1) returns 3. Same total (2) both sides of index 3
    #   v = c(1,1,1,1,1,1) returns 3.5, 3.5 is halfway between 3 and 4. 
    #   There is the same total above and below halfway between index 3 and 4
    #   v = c(c(1,2,3,4,5,6,7,8)) returns 6. Same total (15) both sides of index 6
    #   v = c(1,2,3,4,5,6,7) returns 5.3. below index 5 adds to 10, but below index 6
    #   adds up to 15, which is more than half the total. The centre point is 
    #   between 5 and 6. 
    
    # special case, all the values are the same
    if (min(v) == max(v)) {
        return((length(v) + 1) / 2);
    }
    
    
    # make the minimum value zero
    # this is necessary to avoid problems with negative values
    v <- v - min(v);
    
    
    len <- length(v)
    l <- 1
    r <- len
    total.l <- 0
    half.total <- sum(v) / 2
    
    for (i in (1:len)) {
        new <- total.l + v[i]
        if (new > half.total) {
            center.point <- i
            fraction <- (half.total - total.l) / v[i]
            return (center.point + fraction - 0.5)
        }
        total.l <- new
    }
    
    return(FALSE)
    
}

Normalize <- function (v) {
    # Changes the values of a vector so that they lie 
    # between zero and 1 inclusive
    #
    # Args:
    #    v: vector or matrix (numeric)
    # 
    # Returns:
    #    vector (numeric)
    # 
    # Details:
    #   The lowest value will become zero and the largest value  
    #   will become one, with the other values remaining the same 
    #   relative distance from the max and min. If all the values 
    #  are the same in v, the returned vector will be all zeros
    #   any NA values will be ignored

    
    
    # make the minimum value zero
    v <- v - min(v, na.rm = TRUE)
    
    #make the maximum value 1, keeping the min value zero
    max.val <- max(v, na.rm = TRUE)
    if (max.val != 0) {
        v <- v / max.val
    } else {
        # all vals were the same
        v[!is.na(v)] <- 0.5
    }
    
    return(v)
    
    
}

FrequencyToRowNum <- function (f, hz.per.bin) {
    #  works out the row number of a stft matrix of a given frequency
    #  assumes top of matrix (row 1) = low frequency
    #
    #  Args: 
    #      f: int; frequency in Hz
    #      hz.per.bin: int; the number of Hz per frequency bin
    #
    #  Returns: 
    #      int; the row number
    
    
    # ceil is used because the first row is number 1
    row.num <- ceiling(f / hz.per.bin)
    if (row.num == 0) {
        # if Hz is exactly zero, row number should still be 1
        row.num <- 1
    }
    return(row.num)
}

TimeToColNum <- function (t, frames.per.second, max) {
    # returns out the column number of an stft matrix at 
    # a given number of seconds from the start
    # 
    # Args:
    #   t: float; the number of seconds
    #   frames.per.second: float; the number of time frames 
    #                             for each second of audio
    #
    # Returns:
    #   Int
    
    # ceil is used because column 1 is the 1st (left most) column. 
    col.num <- ceiling(frames.per.second * t)
    if (col.num == 0) {
        # if time is exactly zero, column number should still be 1
        col.num <- 1
    } else if (col.num > max) {
        # due to some inaccuracies, events which finish very close to the edge might end up
        # being calculated 1 frame too far
        col.num <- max
    }
    return(col.num)
}

ColNumToTime <- function (col, frames.per.second) {  
    time <- col/frames.per.second
    return(time)
}

RowNumToFrequency <- function (row, hz.per.bin) {
    return(row * hz.per.bin)
}


# temp to fix the stuffup i made with the filenames
RenameMatlabOutput <- function () {
    
    dir <- 'matlaboutput/'
    rem <- 'matlaboutput'
    files <- list.files(path = dir, full.names = FALSE)
    
    for (i in 1:length(files)) {
        sub <- substring(files[i], 1, nchar(rem))
        if (sub == rem) {
            new <- gsub(rem, "", files[i])
            old.path <- paste0(dir, files[i])
            new.path <- paste0(dir, new)
            file.rename(old.path, new.path)
        }
        
    }
}

SecToTime <- function (sec, decimals = 2,  midnight.is.1st.min = FALSE) {
    #given a second number, returns a string which is the time of day

    sec <- as.numeric(sec)
    if (midnight.is.1st.min) {
        min <- min - 60
    }
    h <- floor(sec / 3600)
    m <- floor(sec / 60) - h * 60
    s1 <- round(sec - (h * 3600 + m * 60), digits = decimals)
    s <- floor(s1)
    cs <- round((s1 - s)*100)
    h <- sprintf("%02d", h)
    m <- sprintf("%02d", m)
    s <- sprintf("%02s", s)
    cs <- sprintf("%02s", cs)
    return(paste(h, m, paste(s, cs, sep = "."), sep = ':'))
}

MinToTime <- function (min, midnight.is.1st.min = FALSE) {
    #given a minute number, returns a string which is the time of day
    # eg 322 returns 5:21 because 5:21am is the 322min minute of the day
    # eg 1 returns 00:00:00 because that is the 1st minute of the day
    
    if (midnight.is.1st.min) {
        min <- min - 1
    }
    h <- floor(min / 60)
    m <- min - h * 60
    h <- sprintf("%02d", h)
    m <- sprintf("%02d", m)
    return(paste(h, m, '00', sep = ':'))
}


FixDate <- function (date) {
    require('stringr')
    #takes a date string which may be written in a different format
    # and reformats it to be consistent
    return(str_replace_all(date, "[^[:digit:]]", '-'))
}

is.wholenumber <- function(x, tol = .Machine$double.eps^0.5) {
    # check if a number is a whole number
    # copied from the help file for is.integer
    abs(x - round(x)) < tol
} 

Between <- function (x, l, u, inclusive = TRUE, ignore.order = TRUE) {
    # returns whether x is between l (lower) and u (upper)  
    if (ignore.order && u < l) {
        t <- l
        l <- u
        u <- t
    }
    if (inclusive) {
        return(x >= l & x <= u)
    } else {
        return(x > l & x < u)
    }  
}

OrderBy <- function (df, col, decreasing = FALSE) {
    #reorders a data frame by the values in col 
    df <- df[order(df[[col]], decreasing = decreasing),]
    return(df)
}

Truncate <- function (v, num = NA) {
    if (is.numeric(num) && length(v) > num) {
        return(v[1:num])
    } else {
        return(v)
    }
}

ExplodeDatetime <- function (datetime) {
    # converts a datetime string from YYYY-MM-DD HH:mm:ss[.ms]
    # where the seconds can optionally have milliseconds to any precision
    # to a list with the items
    # date, time, hour, min, sec, min.in.day, sec.in.day
    
    parts <- unlist(strsplit(datetime, ' ', fixed=TRUE))
    date <-  FixDate(parts[1])
    time <-  parts[2]

    time.parts <- unlist(strsplit(time, ':', fixed=TRUE))
    hour <- as.integer(time.parts[1])
    min <- as.integer(time.parts[2])
    sec <- as.numeric(time.parts[3])
    
    min.in.day <- hour * 60 + min
    sec.in.day <- min.in.day * 60 + sec

    return(list(
        date = date, time = time, 
        hour = hour, min = min, sec = sec,
        min.in.day = min.in.day, sec.in.day = sec.in.day
        ))
    
}

GetIncluded <- function (total.num, num.included, offset = NA) {
    # returns a vector of 1s and 0s 
    # vecor is the same length as total.num, and has num.included 1s in it
    # (fairly) evenly spaced
    num.excluded <- max(c(total.num - num.included, 0))
    ratio <- total.num / num.excluded

    excluded <- ceiling(((1:num.excluded) * ratio))
    if (is.na(offset)) {
        offset <- ceiling(ratio / 2)
    } else {
        offset <- offset %% (min(excluded) + 1)
    }
    excluded <- excluded - offset
    include <- rep(TRUE, total.num)
    include[excluded] <- FALSE
    return(include)
}

Convolve <- function (amp, mask = NA) {
    w <- ncol(amp)
    h <- nrow(amp)
    if (class(mask) != 'matrix') {
        mask <- matrix(c(1,2,1,2,4,2,1,2,1)/16, 3, 3, byrow = TRUE)  
    }
    amp2 <- ExpandMatrix(amp, floor(nrow(mask)/2), floor(ncol(mask)/2))
    total <- matrix(0, nrow = nrow(amp), ncol = ncol(amp))
    for (rr in 1:nrow(mask)) {
        for (cc in 1:ncol(mask)) {
            offset <- amp2[rr:(rr+h-1), cc:(cc+w-1)]
            total <- total + (offset * mask[rr, cc])   
        }
    }
    return(total)
}

Blur <- function (m) {  
    #mask <- matrix(c(1,2,1,2,4,2,1,2,1)/16, 3, 3, byrow = TRUE)
    mask <- matrix(c(1,2,1,2,4,2,1,2,1)/16, 3, 3, byrow = TRUE)
    m2 <- Convolve(m, mask)
    return(m2)  
}

MovingAverage <- function (v, amount = 1, gaussian = TRUE) {
    # existing moving average functions seem to return a shorter output than input
    # becasue edges can't be averaged with values outside the vector
    num <- 2*amount+1  # amount either side plus the original
    l <- length(v)
    v2 <- ExpandVector(v, amount)
    # 1 matrix columen for each version of the vecor
    m <- matrix(rep(NA, l*num), nrow = length(v)) 
    if (gaussian) {
        weights <- GaussianMask(num)
    } else {
        weights <- rep(1/num, num)
    }
    for (i in 1:num) {       
        m[ ,i] <- v2[i:(i+l-1)] * weights[i]  
    }
    v3 <- apply(m, 1, sum)
    return(v3)
}

ExpandVector <- function (v, amount) {
    # expands the vector v by repeating the start and end values by amount
    v <- c(rep(v[1], amount), v, rep(v[length(v)], amount))
    return(v)
}
GaussianMask <- function (width) {
    
    side <- (width-1)/2
    x <- -side:side
    # old crap before I found teh dnorm function
    #mask <- GaussianFunction(exp(1)/(width-1), x, 0, (width-1)/6.66 , 0)
    
    mask <- dnorm(x)
    
    #sum will be slightly less than 1 for small widths
    # correct it
    mask <- mask + ((1 - sum(mask)) / width)
    
    
    return(mask)
}

GaussianFunction <- function (a, x, b = 0, c = 1, d = 0) {
    # see http://en.wikipedia.org/wiki/Gaussian_function
    fx <- a*exp((-((x-b)^2)/(2*(c^2)))+d)  
    return(fx)  
}


ExpandMatrix <- function (m, rr, cc) {
    # copies the edge rows and columns by rr and cc respectively
    if (cc > 0) {
        m <- cbind(matrix(rep(m[,1], cc), ncol = cc), m,  matrix(rep(m[,ncol(m)], cc), ncol = cc) )    
    }
    if (rr > 0) {
        m <- rbind(matrix(rep(m[1,], rr), byrow = TRUE, nrow = rr), m,  matrix(rep(m[nrow(m),], rr), byrow = TRUE, nrow = rr) )
    }
    return(m)
}

ShiftMatrix <- function (m, rr, cc) {
    if (cc < 0) {
        m <- cbind(matrix(rep(m[,1], -cc), ncol = -cc), m)
        m <- m[,-(ncol(m):(ncol(m)+(cc+1)))]
    } else if (cc > 0) {
        m <- cbind(m, matrix(rep(m[,ncol(m)], cc), ncol = cc))
        m <- m[,-(1:cc)]
    }
    if (rr < 0) {
        m <- rbind(matrix(rep(m[1,], -rr), nrow = -rr, byrow = TRUE), m)
        m <- m[-(nrow(m):(nrow(m)+(rr+1))), ]
    } else if (rr > 0) {
        m <- rbind(m, matrix(rep(m[nrow(m),], rr), nrow = rr, byrow = TRUE))
        m <- m[-(1:rr), ]
    }
    return(m)
}

EmptyDataFrame <- function (col.names, num.rows = 0) {
    
    df <- as.data.frame(matrix(NA, nrow = num.rows, ncol = length(col.names)))
    colnames(df) <- col.names
    return(df)
    
}

RgbCol <- function (rgb.vals) {
    if (is.numeric(rgb.vals)) {
        return(rgb(rgb.vals[1], rgb.vals[2], rgb.vals[3], 1))
    } else {
        return(NA)
    }
}

OddVals <- function(v) {
    return(v[seq(1, length(v), 2)])  
}
EvenVals <- function(v) {
    return(v[seq(2, length(v), 2)])  
}

RemoveFileExtension <- function (fn) {
    tmp <- unlist(strsplit(fn,"\\."))
    return(paste0(tmp[1:(length(tmp)-1)], collapse='.'))
}

SampleAtLeastOne <- function (pool, num, prob = NULL, at.least.one.of = NULL) {
    # given a pool of elements and a num greater (or equal) than the number of elements in the at.least.one.of
    # randomly picks num of them, including all of the elements in at.least.one.of at least once
    # pool must contain all of at.least.one.of 
    # if at.least.one.of is not supplied, pool is used. i.e. choose num elements from pool with at least one of each from pool
    
    if (is.null(at.least.one.of)) {
        at.least.one.of <- unique(pool)
    } else {
        if (length(union(pool, at.least.one.of)) != length(unique(pool))) {
            stop('pool must contain all items in mandatory pool')
        }
    }
    
    if (length(at.least.one.of) > num) {
        result <- NA
        stop('num items to return must be greater than the number of items in the mandatory pool')
    } else {
        # first do a normal sample, which doesn't guarantee that every element of the pool is used
        result <- sample.vec(pool, num, replace = TRUE, prob = prob)
        
        missing <- setdiff(at.least.one.of, result)
        
        if (length(missing) > 0) {
            # then, to make sure that all mandatory have been used, assign one of each of the mandatory pool to random spots
            
            # only replace indicies of the result where the value is either not mandatory OR occurs more than once
            can.replace <- which(duplicated(result) | !result %in% at.least.one.of)
            if (length(can.replace) == 0) {
                print('stop')
            }
            to.replace <- sample.vec(can.replace, length(missing), replace = FALSE)
            replacement <- sample.vec(missing, length(missing), replace = FALSE)
            original.result <- result
            result[to.replace] <- replacement 
        }
        

    }
    
    if (length(setdiff(at.least.one.of, result)) > 0) {
        print('stop')
    }
    
    
    return(result)
}

# stupid hack workaround to fix the crap caused by the built in 'convenience' of R's native sample behavious
# i.e if the x is a vector of length 1 is a single number treats is at 1:(x[1])
sample.vec <- function(x, ...) x[sample(length(x), ...)]

HumanReadableTime <- function (secs, suffix = NULL) {
    # for a given number of seconds,
    # returns a string showing the number of hours, mins and seconds
    # for brevity, will ommit seconds if hours > 1
    secs <- round(secs)
    
    m.s  <- secs %% 3600
    h <- (secs - m.s) / 3600
    s <- m.s %% 60
    m <- (m.s - s) / 60

    
    if (h > 0) {
        str <- paste0(h, 'h ', m, 'm')
    } else if (m > 0) {
        str <- paste0( m, 'm ', s, 's')
    } else {
        str <- paste0(s, 'secs') 
    }
    
    if (! is.null(suffix)) {
        str <- paste(str, suffix)
    }
    
    return(str)
    
}

