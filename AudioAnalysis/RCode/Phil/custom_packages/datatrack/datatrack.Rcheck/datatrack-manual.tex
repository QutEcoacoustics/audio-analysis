\nonstopmode{}
\documentclass[a4paper]{book}
\usepackage[times,inconsolata,hyper]{Rd}
\usepackage{makeidx}
\usepackage[utf8,latin1]{inputenc}
% \usepackage{graphicx} % @USE GRAPHICX@
\makeindex{}
\begin{document}
\chapter*{}
\begin{center}
{\textbf{\huge Package `datatrack'}}
\par\bigskip{\large \today}
\end{center}
\begin{description}
\raggedright{}
\item[Title]\AsIs{Manage Metadata Describing Dependencies Between Data Files}
\item[Version]\AsIs{0.0.0.9000}
\item[Author]\AsIs{Philip Eichinski }\email{philip.eichinski@qut.edu.au}\AsIs{}
\item[Maintainer]\AsIs{Philip Eichinski }\email{philip.eichinski@qut.edu.au}\AsIs{}
\item[Description]\AsIs{Provides functions for reading and writing data that record and display
provenance metadata about the file and its dependencies. These dependencies can
be viewed in a directed graph, which can be useful when reading in the data.}
\item[Depends]\AsIs{R (>= 3.2.4)}
\item[License]\AsIs{GPL-2}
\item[LazyData]\AsIs{true}
\item[Imports]\AsIs{rjson, userinput, dviewer}
\item[Suggests]\AsIs{testthat, digest}
\item[RoxygenNote]\AsIs{5.0.1}
\end{description}
\Rdcontents{\R{} topics documented:}
\inputencoding{utf8}
\HeaderA{AddCsvColToMeta}{Updates meta csv column}{AddCsvColToMeta}
%
\begin{Description}\relax
Updates meta csv column
\end{Description}
%
\begin{Usage}
\begin{verbatim}
AddCsvColToMeta()
\end{verbatim}
\end{Usage}
%
\begin{Details}\relax
In previous versions of datatrack, whether to save as csv was specified in the config file
There was no 'csv' column in the metadata. Although this saved a column, it required more configuration
This function adds the 'csv' column and populates the rows according to the json config
\end{Details}
\inputencoding{utf8}
\HeaderA{ClearAccessLog}{Clear the datatrack access log}{ClearAccessLog}
%
\begin{Description}\relax
Clear the access log used to save the most recently accessed version of each name
\end{Description}
%
\begin{Usage}
\begin{verbatim}
ClearAccessLog()
\end{verbatim}
\end{Usage}
\inputencoding{utf8}
\HeaderA{Example1}{Creates a few example data objects with some dependencies between them}{Example1}
%
\begin{Description}\relax
Creates a few example data objects with some dependencies between them
\end{Description}
%
\begin{Usage}
\begin{verbatim}
Example1()
\end{verbatim}
\end{Usage}
\inputencoding{utf8}
\HeaderA{Example2}{Example showing attempting some incompatible dependencies}{Example2}
%
\begin{Description}\relax
Example showing attempting some incompatible dependencies
\end{Description}
%
\begin{Usage}
\begin{verbatim}
Example2()
\end{verbatim}
\end{Usage}
%
\begin{Details}\relax
This should be done after setting up the initial data objects with Example1
Here, we try to save a data object that has indirect dependencies on different versions of the same
name. This should not be allowed, but currently it is.
\end{Details}
\inputencoding{utf8}
\HeaderA{Example3}{Example showing reading data without specifying name}{Example3}
%
\begin{Description}\relax
Example showing reading data without specifying name
\end{Description}
%
\begin{Usage}
\begin{verbatim}
Example3()
\end{verbatim}
\end{Usage}
\inputencoding{utf8}
\HeaderA{Example4}{Example showing reading data with specifying a name}{Example4}
%
\begin{Description}\relax
Example showing reading data with specifying a name
\end{Description}
%
\begin{Usage}
\begin{verbatim}
Example4()
\end{verbatim}
\end{Usage}
\inputencoding{utf8}
\HeaderA{Example5}{Example showing reading data specifying 2 names}{Example5}
%
\begin{Description}\relax
Example showing reading data specifying 2 names
\end{Description}
%
\begin{Usage}
\begin{verbatim}
Example5()
\end{verbatim}
\end{Usage}
%
\begin{Details}\relax
When 2 or more names are specified, it will return the last accessed version of any of those names
\end{Details}
\inputencoding{utf8}
\HeaderA{Example6}{Example showing saving non-csv data}{Example6}
%
\begin{Description}\relax
Example showing saving non-csv data
\end{Description}
%
\begin{Usage}
\begin{verbatim}
Example6()
\end{verbatim}
\end{Usage}
\inputencoding{utf8}
\HeaderA{FixMeta}{Fix the structure of the metadata dataframe}{FixMeta}
%
\begin{Description}\relax
Restores the structure of the metadata dataframe, which might be
necessary if, during a change to datatrack e.g. a new version of the package
extra columns are added, removed or reordered
\end{Description}
%
\begin{Usage}
\begin{verbatim}
FixMeta(meta)
\end{verbatim}
\end{Usage}
%
\begin{Details}\relax
An empty correct meta dataframe is created, then each of the existing
columns are attempted to be matched to a correct column. If no match for an existing
column is found, it is discarded with a warning. If a correct column has not had a match found
for it, it is left blank.

In specific cases of upgrades, transformations might need to be made to the existing columns. If this
happens this function should be added to appropriately. For example, if csv column is removed an a 'class' column
is addeed instead, then specific tranformation from existing csv = 1 rows to class = 'csv' needs to be coded.
\end{Details}
\inputencoding{utf8}
\HeaderA{GetChecksum}{Compute a Checksum of the Metadata}{GetChecksum}
%
\begin{Description}\relax
To quickly compare if the metadata of 2 datatrack projects are the same
We can computer a checksum which ignores the date column.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
GetChecksum(ignore.cols = c("date", "callstack"), algo = "sha1")
\end{verbatim}
\end{Usage}
%
\begin{Details}\relax
After removing the date column of the metadata, performs a hash of the dataframe and returns is
\end{Details}
\inputencoding{utf8}
\HeaderA{Inspector}{Display the visual datatrack inspector}{Inspector}
%
\begin{Description}\relax
Generate the visualisation of saved data objects, their parameters and dependencies
\end{Description}
%
\begin{Usage}
\begin{verbatim}
Inspector(group = FALSE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{group}] string; name of the datatrack data object to filter nodes by.
Will only show nodes that are dependent on, or a dependency of an version of this name
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Gets the metadata in the appropriate json format then passes it to the dataGraph function of the dviewer package
\end{Details}
\inputencoding{utf8}
\HeaderA{ReadDataobject}{Read a Dataobject of a Given Name}{ReadDataobject}
%
\begin{Description}\relax
Given the name and optionally the parameters and dependencies, will read the dataobject previously saved in a datatrack project.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
ReadDataobject(name = NULL, purpose = NA, include.meta = TRUE,
  params = NULL, dependencies = NULL, false.if.missing = FALSE,
  optional = FALSE, use.last.accessed = TRUE, version = NULL)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{name}] String; Optional. The dataobject to read, eg "clusters", "features" etc.  If ommited, will prompt the user with a choice of available names

\item[\code{purpose}] string; Displayed to the user when prompting

\item[\code{include.meta}] bool; if true, will wrap the data to return in a list that also contains the metadata

\item[\code{params}] list; Optional. If supplied, will only consider returning a dataobject with the matching params

\item[\code{dependencies}] list; optional. If supplied, will only consider returning a dataobject with the matching

\item[\code{false.if.missing}] bool; if true, will return false if the file is missing

\item[\code{optional}] boolean; if true, an option is added to select none and return false

\item[\code{use.last.accessed}] boolean; if true (default) will look for the version that was last written or read in this session

\item[\code{version}] int; If the required version is known, then it can be supplied. This version will be used if it exists
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
1) if name is not supplied, will ask user,
2) then if version is supplied, find the that version of the dataobject name. If it doesn't exist, will return false or stop (depending on false.if.missing)
3) looks for the last accessed version if it matches the version OR  params, dependencies
4) if no matching last accessed verion is found, it will ask the user to select a version
This means that for a particular set of params and dependencies, only one version of a particular dataobject name can be used within the same run
5) if the file is found, then it will set the 'last accessed' flag
on the chosen dataobject and it dependencies
\end{Details}
%
\begin{Value}
if include.meta, will return a list that has a 'data' key, that contains the data read in if include.meta is false, will return the data read in, eg data frame if it's a csv
\end{Value}
\inputencoding{utf8}
\HeaderA{ReadOutput}{Legacy Wrapper for ReadDataobject}{ReadOutput}
%
\begin{Description}\relax
Legacy Wrapper for ReadDataobject
\end{Description}
%
\begin{Usage}
\begin{verbatim}
ReadOutput(name = NULL, purpose = NA, include.meta = TRUE,
  params = NULL, dependencies = NULL, false.if.missing = FALSE,
  optional = FALSE, use.last.accessed = TRUE, version = NULL)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{name}] character

\item[\code{purpose}] character

\item[\code{include.meta}] boolean

\item[\code{params}] list

\item[\code{dependencies}] list

\item[\code{false.if.missing}] boolean

\item[\code{optional}] boolean

\item[\code{use.last.accessed}] boolean

\item[\code{version}] int
\end{ldescription}
\end{Arguments}
%
\begin{Value}
list
\end{Value}
\inputencoding{utf8}
\HeaderA{RunAllExamples}{Runs all examples This should produce consistent set of dataobjects and metadata}{RunAllExamples}
%
\begin{Description}\relax
Runs all examples
This should produce consistent set of dataobjects and metadata
\end{Description}
%
\begin{Usage}
\begin{verbatim}
RunAllExamples()
\end{verbatim}
\end{Usage}
\inputencoding{utf8}
\HeaderA{SetConfig}{sets the config values and saves the config file}{SetConfig}
%
\begin{Description}\relax
sets the config values and saves the config file
\end{Description}
%
\begin{Usage}
\begin{verbatim}
SetConfig(...)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{...}] name value pairs as arguments or a list of name value pairs
\end{ldescription}
\end{Arguments}
\inputencoding{utf8}
\HeaderA{SetConfigFile}{Sets the path to the config json file}{SetConfigFile}
%
\begin{Description}\relax
Sets the path to the config json file
\end{Description}
%
\begin{Usage}
\begin{verbatim}
SetConfigFile(path)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{path}] string
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
By Default, datatrack will look for a file called 'datatrack.config.json' in the working directory
This can be overridden by this function. This is not recommended during normal use of datatrack,
since it needs to be called after datatrack is loaded but before it is used, leaving it prone to error.
It is designed for use for unit testing so that datatrack projects can be created and destroyed
\end{Details}
\inputencoding{utf8}
\HeaderA{WriteDataobject}{Write a Dataobject to the Datatrack Project}{WriteDataobject}
%
\begin{Description}\relax
Given any R object, along with parameters and dependencies used when creating the value, will
save the object to disk and record the metadata in the datatrack project
\end{Description}
%
\begin{Usage}
\begin{verbatim}
WriteDataobject(x, name, params = list(), dependencies = list(),
  check.before.overwrite = TRUE, annotations = list())
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] data.frame or Object

\item[\code{name}] string what to call the dataobject. This is used in: the filename and the meta file to keep track of versions and dependencies

\item[\code{params}] list The parameters used when generating this dataobject. Saved in the meta file.

\item[\code{dependencies}] list The dataobjects created from previous steps that were used as input data for the process that created this dataobject List of name/version pairs

\item[\code{check.before.overwrite}] boolean if false, overwrite an existing dataobject if the given parameters and dependencies are the same as the existing one
If the dependency version is given as 0, then datatrack will attempt to look up the last accessed version of that name to use. In other words, use 0 to
specify that datatrack should use the last accessed version as the dependency
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
dataobject will be saved with the filename like: name.version.csv  The version is detected automatically.
If dataobject for this name with the same parameters and dependencies is already saved, then it will be overwritten (after user confirmation).
If params or dependencies are different, then a new version is saved. The version number is created automatically.

The version for the dependency can be ommited (by putting a value < 1). If this happens, then it will be assumed to be the last accessed version
of the dependency dataobject. So, the process which generated the dataobject will have accesed some other dataobject it depends on. Then, when it saves its dataobject
it need only pass the name of the input dataobject without the version, and the function will know which version it was.
\end{Details}
%
\begin{Value}
the version that it gets saved as
\end{Value}
\inputencoding{utf8}
\HeaderA{WriteOutput}{Legacy Wrapper for WriteDataobject}{WriteOutput}
%
\begin{Description}\relax
Legacy Wrapper for WriteDataobject
\end{Description}
%
\begin{Usage}
\begin{verbatim}
WriteOutput(x, name, params = list(), dependencies = list(),
  check.before.overwrite = TRUE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] mixed

\item[\code{name}] character

\item[\code{params}] list

\item[\code{dependencies}] list

\item[\code{check.before.overwrite}] boolean
\end{ldescription}
\end{Arguments}
%
\begin{Value}
int the version of the name that was written
\end{Value}
\inputencoding{utf8}
\HeaderA{WriteStructuredDataobject}{Write a Dataobject to the Datatrack Project}{WriteStructuredDataobject}
%
\begin{Description}\relax
Writes a dataobject where the meta values for the dataobject are included in the list
rather than passed as separate parameters as they would be for WriteDataobject
\end{Description}
%
\begin{Usage}
\begin{verbatim}
WriteStructuredDataobject(x, check.before.overwrite = TRUE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] mixed the data to write

\item[\code{check.before.overwrite}] boolean whether to prompt for user confirmation before overwriting an existing version
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Simply takes the parameters from the list and uses them for WriteDataobject
\end{Details}
\inputencoding{utf8}
\HeaderA{WriteStructuredOutput}{Legacy Wrapper for WriteStructuredDataobject}{WriteStructuredOutput}
%
\begin{Description}\relax
Legacy Wrapper for WriteStructuredDataobject
\end{Description}
%
\begin{Usage}
\begin{verbatim}
WriteStructuredOutput(x, check.before.overwrite = TRUE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] list

\item[\code{check.before.overwrite}] boolean
\end{ldescription}
\end{Arguments}
%
\begin{Value}
int the version of the name that was written
\end{Value}
\printindex{}
\end{document}
