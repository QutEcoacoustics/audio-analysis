\nonstopmode{}
\documentclass[a4paper]{book}
\usepackage[times,inconsolata,hyper]{Rd}
\usepackage{makeidx}
\usepackage[utf8,latin1]{inputenc}
% \usepackage{graphicx} % @USE GRAPHICX@
\makeindex{}
\begin{document}
\chapter*{}
\begin{center}
{\textbf{\huge Package `datatrack'}}
\par\bigskip{\large \today}
\end{center}
\begin{description}
\raggedright{}
\item[Title]\AsIs{Manage Metadata Describing Dependencies Between Data Files}
\item[Version]\AsIs{0.0.0.9000}
\item[Author]\AsIs{Philip Eichinski }\email{philip.eichinski@qut.edu.au}\AsIs{}
\item[Maintainer]\AsIs{Philip Eichinski }\email{philip.eichinski@qut.edu.au}\AsIs{}
\item[Description]\AsIs{Provides functions for reading and writing data that record and display
provenance metadata about the file and its dependencies. These dependencies can
be viewed in a directed graph, which can be useful when reading in the data.}
\item[Depends]\AsIs{R (>= 3.2.4)}
\item[License]\AsIs{GPL-2}
\item[LazyData]\AsIs{true}
\item[Imports]\AsIs{rjson, userinput, dviewer}
\item[Suggests]\AsIs{testthat}
\item[RoxygenNote]\AsIs{5.0.1}
\end{description}
\Rdcontents{\R{} topics documented:}
\inputencoding{utf8}
\HeaderA{AddCsvColToMeta}{Updates meta csv column}{AddCsvColToMeta}
%
\begin{Description}\relax
Updates meta csv column
\end{Description}
%
\begin{Usage}
\begin{verbatim}
AddCsvColToMeta()
\end{verbatim}
\end{Usage}
%
\begin{Details}\relax
In previous versions of datatrack, whether to save as csv was specified in the config file
There was no 'csv' column in the metadata. Although this saved a column, it required more configuration
This function adds the 'csv' column and populates the rows according to the json config
\end{Details}
\inputencoding{utf8}
\HeaderA{ClearAccessLog}{Clear the access log used to save the most recently accessed version of each name}{ClearAccessLog}
%
\begin{Description}\relax
Clear the access log used to save the most recently accessed version of each name
\end{Description}
%
\begin{Usage}
\begin{verbatim}
ClearAccessLog()
\end{verbatim}
\end{Usage}
\inputencoding{utf8}
\HeaderA{D3Inspector}{Main function to generate the viewer}{D3Inspector}
%
\begin{Description}\relax
Main function to generate the viewer
\end{Description}
%
\begin{Usage}
\begin{verbatim}
D3Inspector(group = FALSE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{group}] string; name to filter nodes by
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Gets the metadata in the appropriate json format then passes it to the dataGraph function of the dviewer package
\end{Details}
\inputencoding{utf8}
\HeaderA{Example1}{Creates a few example data objects with some dependencies between them}{Example1}
%
\begin{Description}\relax
Creates a few example data objects with some dependencies between them
\end{Description}
%
\begin{Usage}
\begin{verbatim}
Example1()
\end{verbatim}
\end{Usage}
\inputencoding{utf8}
\HeaderA{Example2}{Example showing attempting some incompatible dependencies}{Example2}
%
\begin{Description}\relax
Example showing attempting some incompatible dependencies
\end{Description}
%
\begin{Usage}
\begin{verbatim}
Example2()
\end{verbatim}
\end{Usage}
%
\begin{Details}\relax
This should be done after setting up the initial data objects with Example1
Here, we try to save a data object that has indirect dependencies on different versions of the same
name. This should not be allowed, but currently it is.
\end{Details}
\inputencoding{utf8}
\HeaderA{ReadDataobject}{reads the dataobject of a given name}{ReadDataobject}
%
\begin{Description}\relax
reads the dataobject of a given name
\end{Description}
%
\begin{Usage}
\begin{verbatim}
ReadDataobject(name = NULL, purpose = NA, include.meta = TRUE,
  params = NULL, dependencies = NULL, false.if.missing = FALSE,
  optional = FALSE, use.last.accessed = TRUE, version = NULL)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{name}] String; Optional. The dataobject to read, eg "clusters", "features" etc.  If ommited, will prompt the user with a choice of available names

\item[\code{purpose}] string; Displayed to the user when prompting

\item[\code{include.meta}] bool; if true, will wrap the data to return in a list that also contains the metadata

\item[\code{params}] list; Optional. If supplied, will only consider returning a dataobject with the matching params

\item[\code{dependencies}] list; optional. If supplied, will only consider returning a dataobject with the matching

\item[\code{false.if.missing}] bool; if true, will return false if the file is missing

\item[\code{optional}] boolean; if true, an option is added to select none and return false

\item[\code{use.last.accessed}] boolean; if true (default) will look for the version that was last written or read in this session

\item[\code{version}] int; If the required version is known, then it can be supplied. This version will be used if it exists
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
1) if name is not supplied, will ask user,
2) then if version is supplied, find the that version of the dataobject name. If it doesn't exist, will return false or stop (depending on false.if.missing)
3) looks for the last accessed version if it matches the version OR  params, dependencies
4) if no matching last accessed verion is found, it will ask the user to select a version
This means that for a particular set of params and dependencies, only one version of a particular dataobject name can be used within the same run
5) if the file is found, then it will set the 'last accessed' flag
on the chosen dataobject and it dependencies
\end{Details}
%
\begin{Value}
if include.meta, will return a list that has a 'data' key, that contains the data read in if include.meta is false, will return the data read in, eg data frame if it's a csv
\end{Value}
\inputencoding{utf8}
\HeaderA{ReadOutput}{Legacy Wrapper for ReadDataobject}{ReadOutput}
%
\begin{Description}\relax
Legacy Wrapper for ReadDataobject
\end{Description}
%
\begin{Usage}
\begin{verbatim}
ReadOutput(name = NULL, purpose = NA, include.meta = TRUE,
  params = NULL, dependencies = NULL, false.if.missing = FALSE,
  optional = FALSE, use.last.accessed = TRUE, version = NULL)
\end{verbatim}
\end{Usage}
\inputencoding{utf8}
\HeaderA{SetConfigFile}{Sets the path to the config json file}{SetConfigFile}
%
\begin{Description}\relax
Sets the path to the config json file
\end{Description}
%
\begin{Usage}
\begin{verbatim}
SetConfigFile(path)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{path}] string
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
By Default, datatrack will look for a file called 'datatrack.config.json' in the working directory
This can be overridden by this function. This is not recommended during normal use of datatrack,
since it needs to be called after datatrack is loaded but before it is used, leaving it prone to error.
It is designed for use for unit testing so that datatrack projects can be created and destroyed
\end{Details}
\inputencoding{utf8}
\HeaderA{WriteDataobject}{writes dataobject to a file}{WriteDataobject}
%
\begin{Description}\relax
writes dataobject to a file
\end{Description}
%
\begin{Usage}
\begin{verbatim}
WriteDataobject(x, name, params = list(), dependencies = list(),
  check.before.overwrite = TRUE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] data.frame or Object

\item[\code{name}] string what to call the dataobject. This is used in: the filename and the meta file to keep track of versions and dependencies

\item[\code{params}] list The parameters used when generating this dataobject. Saved in the meta file.

\item[\code{dependencies}] list The dataobjects created from previous steps that were used as input data for the process that created this dataobject List of name/version pairs
If the dependency version is given as 0, then datatrack will attempt to look up the last accessed version of that name to use. In other words, use 0 to
specify that datatrack should use the last accessed version as the dependency
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
dataobject will be saved with the filename like: name.version.csv  The version is detected automatically.
If dataobject for this name with the same parameters and dependencies is already saved, then it will be overwritten (after user confirmation).
If params or dependencies are different, then a new version is saved. The version number is created automatically.

The version for the dependency can be ommited (by putting a value < 1). If this happens, then it will be assumed to be the last accessed version
of the dependency dataobject. So, the process which generated the dataobject will have accesed some other dataobject it depends on. Then, when it saves its dataobject
it need only pass the name of the input dataobject without the version, and the function will know which version it was.
\end{Details}
%
\begin{Value}
the version that it gets saved as
\end{Value}
\inputencoding{utf8}
\HeaderA{WriteOutput}{Legacy Wrapper for WriteDataobject}{WriteOutput}
%
\begin{Description}\relax
Legacy Wrapper for WriteDataobject
\end{Description}
%
\begin{Usage}
\begin{verbatim}
WriteOutput(x, name, params = list(), dependencies = list(),
  check.before.overwrite = TRUE)
\end{verbatim}
\end{Usage}
\inputencoding{utf8}
\HeaderA{WriteStructuredDataobject}{writes a dataobject where the meta values for the dataobject are included in the list rather than passed as separate parameters}{WriteStructuredDataobject}
%
\begin{Description}\relax
writes a dataobject where the meta values for the dataobject are included in the list
rather than passed as separate parameters
\end{Description}
%
\begin{Usage}
\begin{verbatim}
WriteStructuredDataobject(x, check.before.overwrite = TRUE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] mixed the data to write

\item[\code{check.before.overwrite}] boolean whether to prompt for user confirmation before overwriting an existing version
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Simply takes the parameters from the list and uses them for WriteDataobject
\end{Details}
\inputencoding{utf8}
\HeaderA{WriteStructuredOutput}{Legacy Wrapper for WriteStructuredDataobject}{WriteStructuredOutput}
%
\begin{Description}\relax
Legacy Wrapper for WriteStructuredDataobject
\end{Description}
%
\begin{Usage}
\begin{verbatim}
WriteStructuredOutput(x, check.before.overwrite = TRUE)
\end{verbatim}
\end{Usage}
\printindex{}
\end{document}
